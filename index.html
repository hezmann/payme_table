<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pay Me - Card Game</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #2d5016;
            color: #333;
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: white;
            border-radius: 12px;
            padding: clamp(10px, 1.2vh, 16px) clamp(15px, 2vw, 25px);
            margin: clamp(8px, 1vh, 12px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .header-top-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .header h1 {
            color: #1e3c72;
            margin: 0;
            font-size: clamp(18px, 1.8vw, 24px);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header h1 span {
            display: inline;
        }

        @media (max-width: 800px) {
            .header h1 {
                flex-direction: column;
                gap: 2px;
                font-size: 14px;
                line-height: 1;
                text-align: center;
            }

            .header h1 span {
                display: block;
            }
        }

        @media (max-width: 730px) {
            .header {
                padding: 10px 15px;
            }

            .header-top-row {
                display: grid;
                grid-template-columns: 1fr auto 1fr auto;
                align-items: center;
                gap: 10px;
                width: 100%;
            }

            .header-top-row > h1 {
                grid-column: 1;
                grid-row: 1;
                justify-self: start;
            }

            .header-top-row > .game-info {
                grid-column: 1 / 5;
                grid-row: 1;
                display: contents;
            }

            .game-info .info-item:nth-child(1),
            .game-info .info-item:nth-child(3) {
                display: none;
            }

            .game-info .info-item:nth-child(2) {
                grid-column: 2;
                grid-row: 1;
                justify-self: center;
                text-align: center;
            }

            .game-info .info-item:nth-child(4) {
                grid-column: 3 / 5;
                grid-row: 1;
                justify-self: end;
            }

            .header-message {
                grid-column: 1 / 4;
                grid-row: 2;
                margin: 5px 10px 0 0;
            }

            .header-message .message-pill {
                width: 100%;
                text-align: center;
                display: block;
            }

            .header-actions {
                grid-column: 4;
                grid-row: 2;
                justify-self: end;
                margin: 5px 0 0 0;
            }
        }

        .game-info {
            display: flex;
            gap: clamp(15px, 2vw, 25px);
            flex-wrap: wrap;
            align-items: center;
            font-size: clamp(12px, 1vw, 14px);
            flex-shrink: 1;
            min-width: 0;
        }

        .header-actions {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
            align-items: center;
            margin-left: auto;
        }

        .pause-button {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .pause-button:hover {
            background: #e9ecef;
            transform: scale(1.05);
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            color: #666;
            font-size: 11px;
            margin-bottom: 2px;
        }

        .info-value {
            font-weight: 600;
            color: #1e3c72;
            font-size: 14px;
        }

        .setup-screen {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 500px;
            margin: 100px auto;
            margin-left: auto;
            margin-right: auto;
            width: calc(100% - 40px);
        }

        .game-content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .side-panel {
            width: 280px;
            background: white;
            border-right: 2px solid #dee2e6;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
            flex-shrink: 0;
            margin-left: -280px;
        }

        .side-panel.collapsed {
            margin-left: 0;
        }

        .side-panel-toggle {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid #dee2e6;
            border-left: none;
            border-radius: 0 8px 8px 0;
            padding: 12px 6px;
            cursor: pointer;
            z-index: 50;
            transition: left 0.3s ease;
            font-size: 18px;
        }

        .side-panel-toggle.expanded {
            left: 0;
        }

        .side-panel-toggle.collapsed {
            left: 280px;
        }

        .main-game-area {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding-left: 0;
        }

        .game-screen {
            background: transparent;
            border-radius: 0;
            margin: 0;
            box-shadow: none;
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: clamp(12px, 1.5vw, 20px);
            gap: clamp(12px, 2vh, 20px);
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
        }

        .setup-screen h2 {
            color: #1e3c72;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #2a5298;
        }

        button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #1e3c72;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #5a6268;
        }

        button.danger {
            background: #dc3545;
        }

        button.danger:hover {
            background: #c82333;
        }

        button.success {
            background: #28a745;
            color: white;
        }

        button.success:hover {
            background: #218838;
            color: white;
        }

        .players-grid {
            padding: 10px;
        }

        .player-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: clamp(8px, 1vw, 15px);
            position: relative;
            margin-bottom: 10px;
        }

        .player-card.active {
            border-color: #2a5298;
            background: #e3f2fd;
        }

        .player-card.winner {
            border-color: #28a745;
            background: #d4edda;
        }

        .player-name {
            font-weight: 600;
            margin-bottom: 6px;
            color: #1e3c72;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: clamp(13px, 1.1vw, 16px);
        }

        .player-avatar {
            font-size: clamp(16px, 1.5vw, 24px);
        }

        .player-stats {
            font-size: clamp(10px, 0.85vw, 13px);
            color: #666;
        }

        .player-stats div {
            margin-bottom: 3px;
        }

        .player-dialogue {
            margin-top: 6px;
            font-size: clamp(10px, 0.8vw, 12px);
            font-style: italic;
            color: #555;
            background: white;
            padding: 6px;
            border-radius: 4px;
            min-height: 30px;
        }

        .player-final-hand {
            margin-top: 8px;
            padding: 8px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .player-final-hand h5 {
            font-size: 11px;
            color: #666;
            margin-bottom: 6px;
        }

        .mini-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
        }

        .mini-card {
            font-size: 14px;
            padding: 3px 4px;
            background: white;
            border: 1.5px solid #333;
            border-radius: 3px;
            width: 30px;
            height: 42px;
            min-width: 30px;
            min-height: 42px;
            max-width: 30px;
            max-height: 42px;
            text-align: center;
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            line-height: 1.1;
        }

        .winner-hand-card {
            width: clamp(45px, 7.5vw, 85px);
            height: clamp(68px, 11.25vw, 128px);
            border: 2px solid #333;
            border-radius: 5px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            margin: clamp(2px, 0.4vw, 3px);
            cursor: default;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            position: relative;
            padding: clamp(2px, 0.4vw, 5px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: clamp(6px, 1vw, 10px);
        }

        .winner-hand-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .winner-hand-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .winner-hand-card.wild {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            border-color: #b8860b;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .winner-hand-card.face-card {
            background: white;
            border: none;
            box-shadow: none;
            padding: 0;
            width: clamp(45px, 7.5vw, 85px);
            height: clamp(68px, 11.25vw, 128px);
        }

        .winner-hand-card.face-card.red {
            border: none;
        }

        .winner-hand-card.face-card.black {
            border: none;
        }

        .winner-hand-card.face-card .card-decorative-border {
            display: none;
        }

        .winner-hand-card .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .winner-hand-card .card-corner.top-left {
            position: absolute;
            top: clamp(2px, 0.4vw, 5px);
            left: clamp(2px, 0.4vw, 5px);
        }

        .winner-hand-card .card-corner.bottom-right {
            position: absolute;
            bottom: clamp(2px, 0.4vw, 5px);
            right: clamp(2px, 0.4vw, 5px);
            transform: rotate(180deg);
        }

        .winner-hand-card .card-rank-corner {
            font-size: clamp(11px, 2vw, 16px);
            font-weight: 700;
            font-family: Georgia, serif;
        }

        .winner-hand-card .card-suit-corner {
            font-size: clamp(9px, 1.6vw, 13px);
            margin-top: 1px;
        }

        .winner-hand-card .card-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            font-size: clamp(16px, 4vw, 32px);
            margin: clamp(6px, 1.6vw, 13px) 0;
        }

        .winner-hand-card .face-card-label {
            font-size: clamp(6px, 0.8vw, 8px);
            font-weight: 600;
            text-align: center;
            margin-top: 1px;
            font-family: Georgia, serif;
            letter-spacing: 0.4px;
        }

        .winner-hand-card .card-decorative-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 5px;
            pointer-events: none;
        }

        .winner-hand-card.red .card-decorative-border {
            border: 1.5px solid rgba(220, 53, 69, 0.1);
            margin: 3px;
        }

        .winner-hand-card.black .card-decorative-border {
            border: 1.5px solid rgba(26, 26, 26, 0.1);
            margin: 3px;
        }

        .mini-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .mini-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .mini-card.wild {
            background: #ffd700;
            border-color: #b8860b;
        }

        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .celebration-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            animation: bounceIn 0.5s;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        .celebration-content h2 {
            font-size: 48px;
            color: #28a745;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .celebration-content .winner-name {
            font-size: 32px;
            color: #1e3c72;
            margin-bottom: 10px;
        }

        .celebration-content .coins {
            font-size: 64px;
            margin: 20px 0;
            animation: coinSpin 1s ease-in-out infinite;
        }

        @keyframes coinSpin {
            0%, 100% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
        }

        .score-details-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
            animation: bounceIn 0.3s;
            z-index: 1001;
        }
        .score-details-header {
            padding: 20px;
            border-bottom: 2px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            flex-shrink: 0;
        }
        .score-details-header h2 {
            color: #1e3c72;
            margin: 0;
            font-size: 24px;
        }
        .score-details-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }
        .score-detail-table {
            width: 100%;
            border-collapse: collapse;
        }
        .score-detail-table th {
            background: #1e3c72;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .score-detail-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
            vertical-align: top;
        }
        .score-detail-table tr:hover {
            background: #f8f9fa;
        }
        .score-detail-table tr.winner-round {
            background: #d4edda;
        }
        .score-detail-table tr.winner-round:hover {
            background: #c3e6cb;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #f0f;
            position: absolute;
            animation: confettiFall 3s linear;
        }

        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .game-area {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
        }

        .deck-area {
            display: flex;
            gap: clamp(12px, 2vw, 25px);
            justify-content: center;
            margin: 0;
            flex-wrap: wrap;
            flex: 0 0 auto;
            flex-shrink: 0;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 15px;
            box-shadow: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .deck-pile, .discard-pile {
            text-align: center;
        }

        .pile-label {
            font-size: 11px;
            color: white;
            margin-bottom: 6px;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .card-stack {
            width: clamp(70px, 9vw, 110px);
            height: clamp(105px, 13.5vw, 165px);
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(9px, 1.2vw, 12px);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            position: relative;
        }

        .discard-card {
            width: clamp(70px, 9vw, 110px);
            height: clamp(105px, 13.5vw, 165px);
            border: 2px solid #333;
            border-radius: 6px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            position: relative;
            padding: clamp(3px, 0.5vw, 6px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: clamp(8px, 1.2vw, 12px);
        }

        .discard-card .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .discard-card .card-corner.top-left {
            position: absolute;
            top: clamp(3px, 0.5vw, 6px);
            left: clamp(3px, 0.5vw, 6px);
        }

        .discard-card .card-corner.bottom-right {
            position: absolute;
            bottom: clamp(3px, 0.5vw, 6px);
            right: clamp(3px, 0.5vw, 6px);
            transform: rotate(180deg);
        }

        .discard-card .card-rank-corner {
            font-size: clamp(14px, 2.5vw, 20px);
            font-weight: 700;
            font-family: Georgia, serif;
        }

        .discard-card .card-suit-corner {
            font-size: clamp(11px, 2vw, 16px);
            margin-top: 1px;
        }

        .discard-card .card-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            font-size: clamp(20px, 5vw, 40px);
            margin: clamp(8px, 2vw, 16px) 0;
        }

        .discard-card .face-card-label {
            font-size: clamp(7px, 1vw, 10px);
            font-weight: 600;
            text-align: center;
            margin-top: 1px;
            font-family: Georgia, serif;
            letter-spacing: 0.4px;
        }

        .discard-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .discard-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .discard-card.wild {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            border-color: #b8860b;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
        }

        .discard-card .card-decorative-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 5px;
            pointer-events: none;
        }

        .discard-card.red .card-decorative-border {
            border: 1px solid rgba(220, 53, 69, 0.1);
            margin: 2px;
        }

        .discard-card.black .card-decorative-border {
            border: 1px solid rgba(26, 26, 26, 0.1);
            margin: 2px;
        }

        .card-stack:hover:not(.disabled) {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card-stack.disabled {
            cursor: not-allowed;
            opacity: 1.0;
        }

        .card {
            width: 110px;
            height: 165px;
            border: 2px solid #333;
            border-radius: 6px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            margin: clamp(2px, 0.4vw, 3px);
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            position: relative;
            padding: clamp(3px, 0.5vw, 6px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: clamp(8px, 1.2vw, 12px);
        }

        .card[draggable="true"] {
            cursor: grab;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        .card[draggable="true"]:active {
            cursor: grabbing;
        }

        .card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .card.wild {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            border-color: #b8860b;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: shimmer 2s infinite;
        }

        .card.face-card {
            background: white;
            border: none;
            box-shadow: none;
            padding: 0;
            width: clamp(70px, 9vw, 110px);
            height: clamp(105px, 13.5vw, 165px);
        }

        .card.face-card.red {
            border: none;
        }

        .card.face-card.black {
            border: none;
        }

        .card.face-card .card-decorative-border {
            display: none;
        }

        @keyframes shimmer {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 8px 16px rgba(42, 82, 152, 0.4);
            border-color: #2a5298;
            border-width: 3px;
        }

        .card:hover:not(.disabled) {
            transform: translateY(-4px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card.disabled {
            opacity: 1.0;
            cursor: not-allowed;
        }

        .melds-area .card {
            opacity: 1 !important;
            cursor: grab !important;
        }

        .melds-area .card:active {
            cursor: grabbing !important;
        }

        .card.in-meld {
            opacity: 1.0;
        }

        .card.dragging {
            opacity: 0.3;
        }

        .card-insertion-indicator {
            position: relative;
            width: 4px;
            margin: 0 8px;
            background: #28a745;
            border-radius: 2px;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.8);
            animation: pulse 0.6s ease-in-out infinite;
        }

        .card-insertion-indicator::before {
            content: 'â¬‡';
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #28a745;
            text-shadow: 0 0 10px rgba(40, 167, 69, 0.8);
            animation: bounce 0.6s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { top: -40px; opacity: 1; }
            50% { top: -47px; opacity: 1.0; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .dealing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-in;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .dealing-content {
            text-align: center;
            color: white;
        }

        .dealer-announcement {
            font-size: clamp(24px, 8vw, 48px);
            font-weight: bold;
            margin-bottom: clamp(10px, 3vw, 20px);
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .dealer-avatar {
            font-size: clamp(40px, 15vw, 80px);
            margin: clamp(10px, 3vw, 20px) 0;
            animation: dealerPulse 1s ease-in-out infinite;
        }

        @keyframes dealerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .dealing-info {
            font-size: clamp(14px, 4vw, 24px);
            margin: clamp(5px, 1.5vw, 10px) 0;
            color: #e0e0e0;
        }

        .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .card-corner.top-left {
            position: absolute;
            top: clamp(3px, 0.5vw, 6px);
            left: clamp(3px, 0.5vw, 6px);
        }

        .card-corner.bottom-right {
            position: absolute;
            bottom: clamp(3px, 0.5vw, 6px);
            right: clamp(3px, 0.5vw, 6px);
            transform: rotate(180deg);
        }

        .card-rank-corner {
            font-size: clamp(18px, 3vw, 24px);
            font-weight: 700;
            font-family: Georgia, serif;
        }

        .card-suit-corner {
            font-size: clamp(13px, 2.4vw, 20px);
            margin-top: 1px;
        }

        .card-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            font-size: clamp(28px, 6vw, 52px);
            margin: clamp(8px, 2vw, 16px) 0;
        }

        .card-decorative-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 7px;
            pointer-events: none;
        }

        .card.red .card-decorative-border {
            border: 2px solid rgba(220, 53, 69, 0.1);
            margin: 4px;
        }

        .card.black .card-decorative-border {
            border: 2px solid rgba(26, 26, 26, 0.1);
            margin: 4px;
        }

        .face-card-label {
            font-size: clamp(9px, 1.2vw, 12px);
            font-weight: 600;
            text-align: center;
            margin-top: 1px;
            font-family: Georgia, serif;
            letter-spacing: 0.5px;
        }

        .hand-area {
            background: transparent;
            padding: 40px 20px 20px 20px;
            border-radius: 8px;
            margin: 0;
            position: relative;
            z-index: 10;
            flex: 0 0 auto;
            min-height: 240px;
        }

        .hand-label {
            display: none;
        }

        .cards-container {
            display: flex;
            flex-wrap: nowrap;
            gap: 0;
            justify-content: center;
            overflow-x: auto;
            overflow-y: visible;
            position: relative;
            height: 180px;
            min-height: 210px;
            align-items: flex-end;
            padding-top: 40px;
        }

        .hand-area .cards-container .card {
            position: relative;
            margin: 0 -35px;
            transition: all 0.2s ease;
        }

        .hand-area .cards-container .card:first-child {
            margin-left: 0;
        }

        .hand-area .cards-container .card:hover {
            transform: translateY(-20px) scale(1.05);
            z-index: 100;
        }

        .hand-area .cards-container .card.selected {
            transform: translateY(-25px) scale(1.05);
            z-index: 100;
        }

        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .middle-content-spacer {
            flex: 1 1 auto;
            min-height: 200px;
            max-height: calc(100vh - 400px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .message-box {
            background: #e3f2fd;
            border-left: 4px solid #2a5298;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .message-box.success {
            background: #d4edda;
            border-color: #28a745;
        }

        .message-box.warning {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .message-box.error {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .melds-area {
            margin: 4px 0;
            flex: 1 1 auto;
            min-height: 200px;
            max-height: calc(100vh - 400px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .melds-area.winner-melds {
            min-height: 180px;
            background: rgba(212, 237, 218, 0.3);
            border: 2px solid #28a745;
            border-radius: 12px;
            padding: 12px;
        }

        .winner-hand-fixed { display: none !important; }

        .hand-area {
            order: 3;
        }

        .meld-group {
            margin-bottom: 15px;
            background: #f8f9fa;
            padding: clamp(12px, 1.5vh, 18px);
            border-radius: 8px;
            border: 2px solid #dee2e6;
        }

        .meld-building-area .meld-group {
            margin-bottom: 6px;
            padding: clamp(8px, 1vh, 12px);
            min-height: 100px;
        }

        .meld-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .meld-building-area .meld-header {
            margin-bottom: 6px;
        }

        .meld-label {
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }

        .meld-building-area .meld-label {
            font-size: 12px;
        }

        .meld-building-area {
            background: white;
            border: 2px solid #dee2e6;
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            box-sizing: border-box;
            max-width: min(600px, 50vw);
            width: auto;
            min-height: 120px;
            max-height: 40vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
        }

        .meld-building-area .card {
            width: clamp(45px, 7.5vw, 85px) !important;
            height: clamp(68px, 11.25vw, 128px) !important;
            padding: clamp(2px, 0.4vw, 5px) !important;
            font-size: clamp(6px, 1vw, 10px) !important;
        }

        .meld-building-area .card .card-rank-corner {
            font-size: clamp(11px, 2vw, 16px) !important;
        }

        .meld-building-area .card .card-suit-corner {
            font-size: clamp(9px, 1.6vw, 13px) !important;
        }

        .meld-building-area .card .card-center {
            font-size: clamp(16px, 4vw, 32px) !important;
            margin: clamp(6px, 1.6vw, 13px) 0 !important;
        }

        .meld-building-area .card .face-card-label {
            font-size: clamp(6px, 0.8vw, 8px) !important;
        }

        .meld-building-area .card > div[style*="position: absolute"][style*="fontSize"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }

        .meld-building-area .card > div > div[style*="bottom"][style*="transform: translateX(-50%)"] {
            bottom: clamp(6px, 1vw, 12px) !important;
            font-size: clamp(9px, 1.2vw, 12px) !important;
        }

        .meld-building-area .card > div[style*="position: absolute"][style*="top"][style*="left"][style*="right"][style*="bottom"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }

        .meld-building-area .card > div[style*="position: absolute"][style*="bottom"][style*="transform"] {
            bottom: clamp(8px, 1.2vw, 12px) !important;
            font-size: clamp(9px, 1.2vw, 12px) !important;
            padding: 2px 4px !important;
        }

        .current-meld-section .card > div[style*="position: absolute"][style*="fontSize"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }

        .current-meld-section .card > div[style*="position: absolute"][style*="top"][style*="left"][style*="right"][style*="bottom"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }

        .current-meld-section .cards-container .card > div[style*="position: absolute"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }

        .meld-building-content {
            display: flex;
            gap: clamp(10px, 1.5vw, 16px);
            flex: 1 1 auto;
            min-height: 150px;
            overflow-x: auto;
            overflow-y: visible;
            flex-wrap: nowrap;
            align-items: flex-start;
            padding: 4px;
        }

        .your-melds-section {
            display: flex;
            gap: 12px;
            flex-shrink: 0;
            align-items: flex-start;
        }

        .current-meld-section {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            min-width: clamp(280px, 40vw, 500px);
            max-width: none;
        }

        @media (max-width: 900px) {
            .meld-building-content {
                flex-direction: row;
                overflow-x: auto;
            }

            .your-melds-section,
            .current-meld-section {
                max-width: none;
                min-width: clamp(250px, 35vw, 400px);
            }

            .meld-building-area {
                min-height: 180px;
                padding: clamp(8px, 1.2vh, 12px) clamp(10px, 1.5vw, 14px);
            }
        }

        .saved-meld-item {
            flex-shrink: 0;
            min-width: fit-content;
            display: flex;
            flex-direction: column;
        }

        .meld-building-area h3 {
            color: #856404;
            margin: 0 0 4px 0;
            font-size: 14px;
        }

        .meld-building-area p {
            margin: 0 0 4px 0;
            font-size: 11px;
        }

        .scoreboard {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .scoreboard h3 {
            color: #1e3c72;
            margin-bottom: 15px;
        }

        .score-table {
            width: 100%;
            border-collapse: collapse;
        }

        .score-table th, .score-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .score-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #1e3c72;
        }

        .flying-card {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        @keyframes cardFlip {
            0%, 100% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
        }

        @media  (max-width: 1000px) {
            .game-container {
                padding: 10px;
            }

            .header {
                padding: 15px;
                flex-wrap: wrap;
            }

            .game-info {
                gap: 15px;
            }

            .header-message {
                order: 10;
                flex: 1 1 100%;
                margin: 5px 10px 0 0;
                min-width: 0;
            }

            .header-message .message-pill {
                width: 100%;
            }

            .header-actions {
                order: 11;
                flex: 0 0 auto;
                margin: 5px 0 0 0;
            }

            .card {
                width: 90px;
                height: 135px;
                padding: 6px;
            }

            .card-rank-corner {
                font-size: 20px;
            }

            .card-suit-corner {
                font-size: 16px;
            }

            .card-center {
                font-size: 40px;
            }

            .side-panel {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 100;
                width: 280px;
            }

            .side-panel.collapsed {
                margin-left: -280px;
            }

            .side-panel-toggle {
                position: fixed;
                left: 0;
                z-index: 101;
            }

            .side-panel-toggle.expanded {
                left: 280px;
            }

            .main-game-area {
                padding-left: 0;
            }

            .deck-area {
                flex-direction: row;
                justify-content: center;
                gap: 20px;
            }
        }

        @media  (max-width: 600px) {
            .header {
                flex-wrap: wrap;
                gap: 6px;
                padding: 8px;
            }

            .header h1 {
                font-size: 14px;
                display: flex;
                flex-direction: column;
                align-items: center;
                line-height: 1;
                gap: 2px;
            }

            .game-info {
                flex-wrap: wrap;
                gap: 8px;
            }

            .game-info .info-item:nth-child(1),
            .game-info .info-item:nth-child(3) {
                display: none;
            }

            .info-item {
                font-size: 11px;
                text-align: center;
            }

            .header-actions {
                order: 3;
            }

            .header-message {

                margin: 5px 0 0 0;
            }

            .pause-button {
                padding: 6px 10px;
                font-size: 16px;
            }

            .card {
                width: 70px;
                height: 105px;
                padding: 4px;
            }

            .card-rank-corner {
                font-size: 14px;
            }

            .card-suit-corner {
                font-size: 12px;
            }

            .card-center {
                font-size: 24px;
            }

            .card-stack {
                width: 70px;
                height: 105px;
                font-size: 28px;
            }

            .hand-area, .melds-area {
                padding: 10px;
            }

            .cards-container {
                gap: 4px;
                justify-content: center;
            }

            .deck-area {
                gap: 15px;
            }

            .pile-label {
                font-size: 11px;
            }

            .message-box {
                font-size: 13px;
                padding: 8px;
            }

            .actions button {
                font-size: 14px;
                padding: 10px 16px;
            }

            .meld-building-area {
                min-height: 160px;
                margin: 6px 8px;
                padding: 8px 10px;
            }

            .meld-building-area h3 {
                font-size: 14px;
            }

            .meld-building-content {
                gap: 8px;
                min-height: 130px;
            }

            .current-meld-section {
                min-width: clamp(220px, 80vw, 300px);
            }

            .meld-group {
                padding: 8px;
                margin-bottom: 6px;
            }

            .meld-building-area .meld-group {
                min-height: 120px;
            }

            .winner-hand-fixed { display: none !important; }

            .winner-hand-fixed h3 {
                font-size: 12px;
                margin-bottom: 6px;
            }
        }

        @media  (max-width: 400px) {
            .card {
                width: 60px;
                height: 90px;
                padding: 3px;
            }

            .card-rank-corner {
                font-size: 13px;
            }

            .card-suit-corner {
                font-size: 11px;
            }

            .card-center {
                font-size: 20px;
            }

            .card-stack {
                width: 60px;
                height: 90px;
                font-size: 24px;
            }

            .header h1 {
                font-size: 16px;
            }

            .info-item {
                font-size: 11px;
            }

            .actions button {
                font-size: 13px;
                padding: 8px 12px;
            }

            .meld-building-area {
                min-height: 140px;
                margin: 4px 6px;
                padding: 6px 8px;
            }

            .meld-building-content {
                min-height: 110px;
            }

            .current-meld-section {
                min-width: 200px;
            }

            .meld-building-area .meld-group {
                min-height: 100px;
            }
        }

.header{ margin: 6px; padding: 8px 12px; border-radius: 10px; }
.header h1{ font-size: 22px; }
.header .stats{ gap: 12px; }
.main-game-area{ padding-left: 12px; }
.game-screen{ padding: 10px 12px; }
.message-container{ margin: 6px; }
.message-box{ margin: 8px 0; padding: 8px 10px; }
.meld-group{ margin-bottom: 8px; padding: 10px; }
.actions{ margin: 8px 0; gap: 8px; }

.hand-area{ position: sticky; bottom: 0; left: 0; z-index: 40; margin: 8px 0 0 0; border-radius: 12px; background: rgba(248,249,250,0.98); backdrop-filter: blur(6px); box-shadow: 0 -6px 16px rgba(0,0,0,0.10); padding: 8px 10px; }
.hand-label{ margin-bottom: 6px; font-size: 14px; }
.cards-container{ gap: 6px; }
.card{ box-shadow: 0 2px 6px rgba(0,0,0,0.10); }

  @media (max-width: 1400px){ .side-panel{ width: 240px; } .side-panel-toggle.expanded{ left: 240px; } .side-panel.collapsed{ margin-left: -240px; } }
  @media (max-width: 768px){ .side-panel{ width: 260px; } .side-panel-toggle.expanded{ left: 260px; } .side-panel.collapsed{ margin-left: -260px; } .main-game-area{ padding-left: 0 !important; } }

        .header-message{
            display:flex;
            flex-direction:column;
            gap:6px;
            flex: 1 1 auto;
            align-items: stretch;
            justify-content: center;
            margin: 0 10px;
            min-width: 0;
        }
        .message-pill{
            display:block;
            padding: 8px 16px;
            border-radius: 999px;
            background: #d4edda;
            color: #155724;
            font-size: clamp(11px, 3vw, 13px);
            font-weight: 600;
            line-height: 1.3;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .message-pill.success{
            background:#d4edda;
            color:#155724;
        }
        .message-pill.warning{
            background:#fff3cd;
            color:#856404;
        }
        .ai-highlight .card-stack{
            box-shadow: 0 0 0 3px rgba(40,167,69,0.65);
            border-radius: 10px;
            animation: aiPulse 0.9s ease-in-out 1;
        }
        @keyframes aiPulse{
            0%{ transform: scale(1); }
            40%{ transform: scale(1.04); }
            100%{ transform: scale(1); }
        }
        .sticky-winner{
            position: relative;
            z-index: 10;
            background: rgba(255,255,255,0.98);
            border-radius: 12px;
            padding: 8px 10px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.12);
            min-height: 240px;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .wild-picker-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .wild-picker-modal {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .wild-picker-modal h3 {
            margin: 0 0 15px 0;
            color: #1e3c72;
            text-align: center;
        }

        .wild-picker-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .wild-picker-card {
            width: 50px;
            height: 70px;
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            font-weight: bold;
        }

        .wild-picker-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .wild-picker-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .wild-picker-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .wild-picker-card .rank {
            font-size: 18px;
        }

        .wild-picker-card .suit {
            font-size: 20px;
        }

        .wild-picker-cancel {
            display: block;
            width: 100%;
            padding: 10px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .wild-picker-cancel:hover {
            background: #5a6268;
        }
</style>

<style>

.game-content-wrapper { position: relative; }

.hand-area.sticky-hand,
.your-hand-panel{
  position: fixed;

  bottom: 10px;
  left: 20px;
  right: 20px;
  z-index: 60;

  background: transparent;
  border: none;
  border-radius: 0;
  box-shadow: none;

  padding-bottom: env(safe-area-inset-bottom);
  padding-top: 60px;
}

.game-content-wrapper:has(.side-panel.collapsed) .hand-area.sticky-hand,
.game-content-wrapper:has(.side-panel.collapsed) .your-hand-panel{
  left: calc(280px + 20px);
}

.game-screen{
  padding-bottom: clamp(220px, 25vh, 260px);
}

.your-final-play-panel {
  position: fixed;
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 60;

  background: transparent;
  border: none;
  border-radius: 0;
  box-shadow: none;
  padding-bottom: env(safe-area-inset-bottom);

  padding: 8px 12px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;

  max-height: 50vh;
  overflow: hidden;
}

.game-content-wrapper:has(.side-panel.collapsed) .your-final-play-panel{
  left: calc(280px + 20px);
}

.your-final-play-panel .final-play-content {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  overflow-x: visible;
}

.your-final-play-panel h3 {
  color: #856404;
  margin: 0 0 8px 0;
  font-size: 16px;
  flex-shrink: 0;
}
</style>

<style>

.winner-hand-header-row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px;}
.winner-tip-pill{background:#d1ecf1;border:1px solid #bee5eb;color:#0c5460;font-weight:700;font-size:13px;padding:6px 10px;border-radius:10px;white-space:nowrap;}
</style>

<style>
<style>

.meld-group .cards-container,
.meld-building-area .cards-container{
  padding: 12px;
  background: rgba(255,255,255,0.55);
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 12px;
  min-height: 120px;
  overflow-x: auto;
  flex-wrap: nowrap;
  justify-content: flex-start;
}
</style>

<style>

.side-panel .joker-icon,
.player-panel .joker-icon {
  width: calc(var(--card-width) - 2px);
  height: calc(var(--card-height) - 2px);
  padding: 1px;
  box-sizing: border-box;
}
.side-panel .joker-icon img,
.player-panel .joker-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

        .table-player-position {
            position: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 5;
        }

        .table-player-position.position-top {
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
        }

        .table-player-position.position-left {
            top: 50%;
            left: 80px;
            transform: translateY(-50%);
        }

        .table-player-position.position-right {
            top: 50%;
            right: 80px;
            transform: translateY(-50%);
        }

        .table-player-info {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid #dee2e6;
        }

        .table-player-info.active {
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.3);
        }

        .table-player-avatar {
            font-size: 24px;
        }

        .table-player-name {
            font-weight: 600;
            color: #1e3c72;
            font-size: 14px;
        }

        .table-card-count {
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .table-player-cards {
            display: flex;
            position: relative;
            height: 120px;
        }

        .table-player-cards .card.face-down {
            width: 110px;
            height: 165px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: 2px solid #1a2a4a;
            border-radius: 6px;
            position: relative;
            margin: 0 -20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .table-player-cards .card.face-down::after {
            content: 'ðŸ‚ ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: rgba(255,255,255,0.3);
        }

        .position-top .table-player-cards .card.face-down { z-index: auto; }

        .position-left .table-player-cards {
            flex-direction: row;
            height: 120px;
            width: auto;
        }
        .position-left .table-player-cards .card.face-down {
            margin: 0 -20px;
            transform: none;
        }

        .position-right .table-player-cards {
            flex-direction: row;
            height: 120px;
            width: auto;
        }
        .position-right .table-player-cards .card.face-down {
            margin: 0 -20px;
            transform: none;
        }

        .payme-button {
            position: fixed;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: 3px solid #1e7e34;
            padding: 15px 40px;
            border-radius: 12px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.2s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .payme-button:hover {
            transform: translateX(-50%) translateY(-3px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
            background: linear-gradient(135deg, #20c997 0%, #28a745 100%);
        }

        .payme-button:active {
            transform: translateX(-50%) translateY(-1px);
        }

        .table-player-winner-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-width: 400px;
            justify-content: center;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .position-top .table-player-winner-cards {
            margin-top: 10px;
        }

        .position-left .table-player-winner-cards,
        .position-right .table-player-winner-cards {
            flex-direction: row;
            max-width: 600px;
        }

        .human-winner-cards {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            max-width: 90vw;
            z-index: 60;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .human-winner-cards .meld-group {
            display: inline-flex;
            flex-direction: row;
            gap: 3px;
            padding: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            margin: 3px;
        }

        .table-player-winner-cards .meld-group {
            display: inline-flex;
            flex-direction: row;
            gap: 3px;
            padding: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            margin: 3px;
        }

        .table-player-winner-cards .meld-group.can-drop {
            border-color: #28a745;
            border-style: dashed;
        }

        .table-player-position {
            position: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 5;
        }

        .table-player-position.position-top {
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
        }

        .table-player-position.position-left {
            top: 50%;
            left: 80px;
            transform: translateY(-50%);
        }

        .table-player-position.position-right {
            top: 50%;
            right: 80px;
            transform: translateY(-50%);
        }

        .table-player-info {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid #dee2e6;
        }

        .table-player-info.active {
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.3);
        }

        .table-player-avatar {
            font-size: 24px;
        }

        .table-player-name {
            font-weight: 600;
            color: #1e3c72;
            font-size: 14px;
        }

        .table-player-cards {
            display: flex;
            position: relative;
            height: 120px;
        }

        .table-player-cards .card.face-down {
            width: 110px;
            height: 165px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: 2px solid #1a2a4a;
            border-radius: 6px;
            position: relative;
            margin: 0 -35px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .table-player-cards .card.face-down::after {
            content: 'ðŸ‚ ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: rgba(255,255,255,0.3);
        }

        .table-player-winner-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-width: 600px;
            justify-content: center;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .table-player-winner-cards .meld-group {
            display: inline-flex;
            flex-direction: row;
            gap: 3px;
            padding: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            margin: 3px;
        }

        .table-player-winner-cards .meld-group.can-drop {
            border-color: #28a745;
            border-style: dashed;
        }

        .human-winner-cards {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            max-width: 90vw;
            z-index: 60;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .human-winner-cards .meld-group {
            display: inline-flex;
            flex-direction: row;
            gap: 3px;
            padding: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            margin: 3px;
        }

</style>

</head>
<body>
    <div id="root"></div>

    <script type="text/babel">        const { useState, useEffect, useRef } = React;
        const CARD_VALUES = {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
            'J': 11, 'Q': 12, 'K': 13, 'A': 14
        };
        const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const AI_CHARACTERS = [
            {
                name: "Heather",
                avatar: "ðŸ‘©â€ðŸ’»",
                dialogues: {
                    start: ["Let's do this!", "Ready to win!", "Here we go!"],
                    draw: ["Come on, good card...", "What do I have?", "Let's see..."],
                    discard: ["Don't need this.", "Out you go.", "This one."],
                    payme: ["PAY ME! Yes!", "Got it! Everyone pay!", "Pay up, everyone!"],
                    lose: ["Darn it.", "So close!", "Next time."]
                }
            },
            {
                name: "Holly",
                avatar: "ðŸ‘©â€âš•ï¸",
                dialogues: {
                    start: ["Excited!", "Let's play!", "Ready!"],
                    draw: ["Ooh, what is it?", "Come on...", "Please be good!"],
                    discard: ["Bye!", "This one goes.", "Don't want it."],
                    payme: ["PAY ME! Woohoo!", "Yes! Pay me!", "I won! Pay up!"],
                    lose: ["Aww!", "Oh well!", "Almost!"]
                }
            },
            {
                name: "Andy",
                avatar: "ðŸ‘¨â€ðŸ¦³",
                dialogues: {
                    start: ["Alright.", "Let's go.", "Ready."],
                    draw: ["What've we got?", "Here goes.", "Let's see."],
                    discard: ["This one.", "Out.", "Gone."],
                    payme: ["PAY ME! Got it!", "Pay up everyone!", "That's how it's done!"],
                    lose: ["Damn.", "Not this time.", "Whatever."]
                }
            },
            {
                name: "Stefan",
                avatar: "ðŸ‘¨â€ðŸ”¬",
                dialogues: {
                    start: ["Time to focus.", "Concentrating now.", "Let's analyze."],
                    draw: ["Interesting...", "Hmm.", "Calculating..."],
                    discard: ["Optimal choice.", "This goes.", "Logical."],
                    payme: ["PAY ME! Perfect!", "Calculated correctly!", "Everyone pay!"],
                    lose: ["Interesting hand.", "The math didn't work out.", "Next calculation."]
                }
            },
            {
                name: "Michelle",
                avatar: "ðŸ‘©â€ðŸ’¼",
                dialogues: {
                    start: ["This is fun!", "Love this!", "Ready to play!"],
                    draw: ["What's it gonna be?", "Exciting!", "Ooh!"],
                    discard: ["This one!", "Bye card!", "Out!"],
                    payme: ["PAY ME! Amazing!", "Yes! Everyone pay!", "Got it!"],
                    lose: ["Great game!", "Well played everyone!", "Fun round!"]
                }
            },
            {
                name: "Joanne",
                avatar: "ðŸ‘©â€ðŸ¦±",
                dialogues: {
                    start: ["Here we go again.", "Another round.", "Alright."],
                    draw: ["Let's see what we have.", "Hmm.", "Okay."],
                    discard: ["This one goes.", "There.", "Done."],
                    payme: ["PAY ME! Finally!", "About time! Pay up!", "Everyone pay!"],
                    lose: ["Oh dear.", "Not my round.", "That's fine."]
                }
            },
            {
                name: "Ashley",
                avatar: "ðŸ‘±â€â™€ï¸",
                dialogues: {
                    start: ["Let's have fun!", "Ready!", "Excited!"],
                    draw: ["What do I get?", "Come on!", "Let's see!"],
                    discard: ["Don't need this.", "Out!", "This one."],
                    payme: ["PAY ME! Yay!", "Got it! Pay up!", "Everyone pay me!"],
                    lose: ["Aww well.", "Next time!", "Good game!"]
                }
            },
            {
                name: "Jim",
                avatar: "ðŸ‘·â€â™‚ï¸",
                dialogues: {
                    start: ["Let's play.", "Ready.", "Here we go."],
                    draw: ["What's this?", "Alright.", "Let me see."],
                    discard: ["This one.", "Out.", "There."],
                    payme: ["PAY ME! Ha!", "Got it! Everyone pay!", "Pay up!"],
                    lose: ["Good round.", "Well played.", "Nice game."]
                }
            },
            {
                name: "Andi",
                avatar: "ðŸ‘¨â€ðŸ¦³",
                dialogues: {
                    start: ["Chill vibes.", "Let's go.", "Ready."],
                    draw: ["Cool.", "Alright.", "Let's see."],
                    discard: ["Later.", "Peace.", "Out."],
                    payme: ["PAY ME! Nice!", "Sweet! Pay up!", "Got it!"],
                    lose: ["All good.", "No worries.", "It happens."]
                }
            },
            {
                name: "Jordan",
                avatar: "ðŸ‘©â€ðŸ¦°",
                dialogues: {
                    start: ["Ready to crush this.", "Watch this.", "Easy."],
                    draw: ["Give me gold.", "Here it comes.", "Perfect."],
                    discard: ["Trash.", "Don't need it.", "Gone."],
                    payme: ["PAY ME! Too easy!", "Boom! Pay up!", "Who's the best?"],
                    lose: ["Just warming up.", "Lucky hand.", "I'll get you."]
                }
            },
            {
                name: "Morgan",
                avatar: "ðŸ‘©â€ðŸ¦±",
                dialogues: {
                    start: ["Let's see what happens.", "Okay.", "Ready."],
                    draw: ["What is it?", "Hmm.", "Alright."],
                    discard: ["This.", "Out.", "Gone."],
                    payme: ["PAY ME! Great!", "Yes! Pay up!", "Got it!"],
                    lose: ["Oh well.", "Not this time.", "Good game."]
                }
            },
            {
                name: "Matt",
                avatar: "ðŸ‘¨â€ðŸ¦±",
                dialogues: {
                    start: ["Optimizing strategy.", "Calculating.", "Ready."],
                    draw: ["Analyzing.", "Processing.", "Let's see."],
                    discard: ["Best move.", "This one.", "Optimal."],
                    payme: ["PAY ME! Calculated!", "Perfect! Pay up!", "As predicted!"],
                    lose: ["Suboptimal hand.", "Recalculating.", "Interesting."]
                }
            },
            {
                name: "Peyton",
                avatar: "ðŸ§‘",
                dialogues: {
                    start: ["Let's go!", "Ready!", "Here we go!"],
                    draw: ["What is it?", "Come on...", "Let's see..."],
                    discard: ["This one.", "Out.", "Done."],
                    payme: ["PAY ME! Yes!", "Got it!", "Pay up!"],
                    lose: ["Aww.", "Next time.", "Good game."]
                }
            },
            {
                name: "Brian",
                avatar: "ðŸ‘¨â€ðŸ¦²",
                dialogues: {
                    start: ["Ready to play.", "Let's do this.", "Here we go."],
                    draw: ["What've we got?", "Alright.", "Let's see."],
                    discard: ["This one.", "Out.", "Gone."],
                    payme: ["PAY ME! Perfect!", "Got it! Pay up!", "Everyone pay!"],
                    lose: ["Good game.", "Well played.", "Next round."]
                }
            },
            {
                name: "Helen",
                avatar: "ðŸ‘©â€ðŸ¦³",
                dialogues: {
                    start: ["Let's have fun!", "Ready!", "Here we go!"],
                    draw: ["What is it?", "Come on...", "Let's see!"],
                    discard: ["This one.", "Out!", "Done."],
                    payme: ["PAY ME! Wonderful!", "Yes! Pay up!", "Got it!"],
                    lose: ["Oh well.", "Good game!", "Next time."]
                }
            }
        ];
        let __cardIdCounter = 0;
        function createDeck() {
            const deck = [];
            for (let suit of SUITS) {
                for (let rank of RANKS) {
                    deck.push({
                        rank,
                        suit,
                        isRed: suit === 'â™¥' || suit === 'â™¦',
                        id: `${rank}${suit}-${__cardIdCounter++}`
                    });
                }
            }
            deck.push({ rank: 'JOKER', suit: 'ðŸƒ', isRed: true, id: `JOKER-${__cardIdCounter++}` });
            deck.push({ rank: 'JOKER', suit: 'ðŸƒ', isRed: false, id: `JOKER-${__cardIdCounter++}` });
            return deck;
        }
function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }
        function getDialogue(character, situation) {
            const dialogues = character.dialogues[situation] || [];
            return dialogues[Math.floor(Math.random() * dialogues.length)] || "";
        }
        function isWild(card, round) {
            if (!card) return false;
            if (card.rank === 'JOKER') return true;
            const roundCardCount = round + 2;
            return card.rank === roundCardCount.toString() ||
                   (roundCardCount === 11 && card.rank === 'J') ||
                   (roundCardCount === 12 && card.rank === 'Q') ||
                   (roundCardCount === 13 && card.rank === 'K');
        }
        function sortMeld(meld, round) {
            if (!meld || meld.length === 0) return meld;
            const isRun = isValidRun(meld, round);
            const isSet = isValidSet(meld, round);
            if (isRun) {
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                const cardsWithRanks = meld.map(card => {
                    let effectiveRank = card.rank;
                    if (card.representsCard) {
                        const match = card.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                        if (match) {
                            effectiveRank = match[1];
                        }
                    }
                    const rankIndex = rankOrder.indexOf(effectiveRank);
                    return { card: {...card}, rankIndex };
                });
                const hasAce = cardsWithRanks.some(c => c.rankIndex === 0);
                const hasHighCards = cardsWithRanks.some(c => c.rankIndex >= 10);
                if (hasAce && hasHighCards) {
                    const allRankIndices = cardsWithRanks.map(c => c.rankIndex).filter(i => i >= 0);
                    const nonAceIndices = allRankIndices.filter(i => i !== 0);
                    if (nonAceIndices.length === 0) {
                        cardsWithRanks.sort((a, b) => a.rankIndex - b.rankIndex);
                        return cardsWithRanks.map(c => c.card);
                    }
                    const minNonAce = Math.min(...nonAceIndices);
                    const maxNonAce = Math.max(...nonAceIndices);
                    if (minNonAce >= 9 || (maxNonAce === 12 && hasHighCards)) {
                        const sorted = cardsWithRanks.map(c => ({
                            ...c,
                            sortIndex: c.rankIndex === 0 ? 13 : c.rankIndex
                        })).sort((a, b) => a.sortIndex - b.sortIndex);
                        return sorted.map(c => c.card);
                    }
                }
                cardsWithRanks.sort((a, b) => a.rankIndex - b.rankIndex);
                return cardsWithRanks.map(c => c.card);
            }
            if (isSet) {
                const suitOrder = { 'â™ ': 0, 'â™¥': 1, 'â™¦': 2, 'â™£': 3 };
                const cardsWithSuits = meld.map(card => {
                    let effectiveSuit = card.suit;
                    if (card.representsCard) {
                        const match = card.representsCard.match(/([â™¥â™¦â™£â™ ])$/);
                        if (match) {
                            effectiveSuit = match[1];
                        }
                    }
                    const suitIndex = suitOrder[effectiveSuit] !== undefined ? suitOrder[effectiveSuit] : 999;
                    return { card: {...card}, suitIndex };
                });
                cardsWithSuits.sort((a, b) => a.suitIndex - b.suitIndex);
                return cardsWithSuits.map(c => c.card);
            }
            return meld;
        }
        function isValidRun(cards, round) {
            if (cards.length < 3) return false;
            const markedCards = cards.map(c => ({
                ...c,
                isWildForRound: c.isWildForRound === true ? true : isWild(c, round)
            }));
            const processedCards = markedCards.map(c => {
                if (c.isWildForRound && c.representsCard) {
                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)([â™¥â™¦â™£â™ ])$/);
                    if (match) {
                        return { ...c, rank: match[1], suit: match[2], isWildForRound: false };
                    }
                }
                return c;
            });
            const nonWilds = processedCards.filter(c => !c.isWildForRound);
            if (nonWilds.length === 0) return false;
            const suit = nonWilds[0].suit;
            const suitCheckPassed = nonWilds.every(c => c.suit === suit);
            if (!suitCheckPassed) {
                return false;
            }
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const indices = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
            for (let i = 1; i < indices.length; i++) {
                if (indices[i] === indices[i-1]) {
                    return false;
                }
            }
            const wilds = processedCards.length - nonWilds.length;
            let gapsNeeded = 0;
            for (let i = 1; i < indices.length; i++) {
                gapsNeeded += indices[i] - indices[i-1] - 1;
            }
            if (gapsNeeded <= wilds) return true;
            if (indices[0] === 0) {
                const indicesAceHigh = indices.slice(1).concat([13]);
                let gapsNeededAceHigh = 0;
                for (let i = 1; i < indicesAceHigh.length; i++) {
                    gapsNeededAceHigh += indicesAceHigh[i] - indicesAceHigh[i-1] - 1;
                }
                if (gapsNeededAceHigh <= wilds) return true;
            }
            return false;
        }
        function assignJokersInRun(meld, round) {
            if (!meld || meld.length === 0) return meld;
            const validMeld = meld.filter(c => c && c.rank && c.suit);
            if (validMeld.length === 0) return meld;
            const markedCards = validMeld.map(c => ({...c, isWildForRound: isWild(c, round)}));
            const nonWilds = markedCards.filter(c => !c.isWildForRound);
            const wilds = markedCards.filter(c => c.isWildForRound);
            if (wilds.length === 0) return validMeld;
            if (nonWilds.length === 0) return validMeld;
            const suit = nonWilds[0].suit;
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            let nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
            let useAceHigh = false;
            if (nonWildRanks[0] === 0 && nonWildRanks.length > 1) {
                const gapsAceLow = nonWildRanks[nonWildRanks.length - 1] - nonWildRanks[0] - (nonWildRanks.length - 1);
                const ranksAceHigh = nonWildRanks.slice(1).concat([13]).sort((a, b) => a - b);
                const gapsAceHigh = ranksAceHigh[ranksAceHigh.length - 1] - ranksAceHigh[0] - (ranksAceHigh.length - 1);
                if (gapsAceHigh < gapsAceLow) {
                    useAceHigh = true;
                    nonWildRanks = ranksAceHigh;
                }
            }
            const result = [...validMeld];
            const allRanks = [];
            for (let i = 0; i < nonWildRanks.length - 1; i++) {
                allRanks.push(nonWildRanks[i]);
                for (let gap = nonWildRanks[i] + 1; gap < nonWildRanks[i + 1]; gap++) {
                    allRanks.push(gap);
                }
            }
            allRanks.push(nonWildRanks[nonWildRanks.length - 1]);
            let remaining = wilds.length - (allRanks.length - nonWildRanks.length);
            let lowIdx = allRanks[0];
            let highIdx = allRanks[allRanks.length - 1];
            while (remaining > 0 && lowIdx > 0) {
                allRanks.unshift(lowIdx - 1);
                lowIdx--;
                remaining--;
            }
            while (remaining > 0 && highIdx < (useAceHigh ? 13 : 12)) {
                allRanks.push(highIdx + 1);
                highIdx++;
                remaining--;
            }
            const assignedRanks = new Set(nonWildRanks);
            result.forEach(card => {
                if (isWild(card, round) && card.representsCard) {
                    const match = card.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                    if (match) {
                        const rankStr = match[1];
                        const rankIdx = rankStr === 'A' && useAceHigh ? 13 : rankOrder.indexOf(rankStr);
                        if (rankIdx >= 0) {
                            assignedRanks.add(rankIdx);
                        }
                    }
                }
            });
            result.forEach(card => {
                if (isWild(card, round) && !card.representsCard) {
                    for (let rank of allRanks) {
                        if (!assignedRanks.has(rank)) {
                            let rankStr;
                            if (rank === 13) {
                                rankStr = 'A';
                            } else {
                                rankStr = rankOrder[rank];
                            }
                            card.representsCard = `${rankStr}${suit}`;
                            assignedRanks.add(rank);
                            break;
                        }
                    }
                }
            });
            return result;
        }
        function autoAssignWildsInRun(meld, round) {
            if (!meld || meld.length === 0) return meld;
            const result = meld.map(c => ({...c}));
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const nonWilds = result.filter(c => !isWild(c, round));
            const unassignedWilds = result.filter(c => isWild(c, round) && !c.representsCard);
            if (nonWilds.length === 0 || unassignedWilds.length === 0) return result;
            const suit = nonWilds[0].suit;
            let nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
            let useAceHigh = false;
            if (nonWildRanks.includes(0) && nonWildRanks.length > 1) {
                const maxRankWithoutAce = Math.max(...nonWildRanks.filter(r => r !== 0));
                if (maxRankWithoutAce >= 10) {
                    useAceHigh = true;
                    nonWildRanks = nonWildRanks.filter(r => r !== 0).concat([13]);
                    nonWildRanks.sort((a, b) => a - b);
                }
            }
            const assignedWilds = result.filter(c => isWild(c, round) && c.representsCard);
            const assignedRanks = new Set(nonWildRanks);
            assignedWilds.forEach(card => {
                const match = card.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                if (match) {
                    const rankStr = match[1];
                    const rankIdx = rankStr === 'A' && useAceHigh ? 13 : rankOrder.indexOf(rankStr);
                    if (rankIdx >= 0) assignedRanks.add(rankIdx);
                }
            });
            const minRank = Math.min(...assignedRanks);
            const maxRank = Math.max(...assignedRanks);
            const totalCardsNeeded = maxRank - minRank + 1;
            const totalCardsAvailable = nonWilds.length + assignedWilds.length + unassignedWilds.length;
            const gaps = [];
            for (let r = minRank; r <= maxRank; r++) {
                if (!assignedRanks.has(r)) {
                    gaps.push(r);
                }
            }
            if (gaps.length === unassignedWilds.length) {
                gaps.sort((a, b) => a - b);
                unassignedWilds.forEach((wild, idx) => {
                    const rankIdx = gaps[idx];
                    const rankStr = rankIdx === 13 ? 'A' : rankOrder[rankIdx];
                    const wildInResult = result.find(c => c === wild || (c.id === wild.id && isWild(c, round) && !c.representsCard));
                    if (wildInResult) {
                        wildInResult.representsCard = `${rankStr}${suit}`;
                    }
                });
            }
            return result;
        }
        function canExtendRunOnEnd(meld, card, round) {
            if (!meld || meld.length < 3 || !card) return false;
            const rankOrder = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            const effective = meld.map(c => {
                if (c && c.representsCard) {
                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)([â™¥â™¦â™£â™ ])$/);
                    if (match) return { rank: match[1], suit: match[2] };
                }
                return { rank: c.rank, suit: c.suit };
            }).filter(x => x.rank && x.suit);
            if (effective.length === 0) return false;
            const runSuit = effective[0].suit;
            let indices = effective.map(c => rankOrder.indexOf(c.rank)).filter(i => i >= 0);
            if (indices.length === 0) return false;
            const hasAce = indices.includes(0);
            const hasHigh = indices.some(i => i >= 10);
            const hasLowBeyondAce = indices.some(i => i >= 1 && i <= 8);
            if (hasAce && hasHigh && !hasLowBeyondAce) {
                indices = indices.map(i => i === 0 ? 13 : i);
            }
            const minIdx = Math.min(...indices);
            const maxIdx = Math.max(...indices);
            const below = minIdx - 1;
            const above = maxIdx + 1;
            const possibleRanks = [];
            if (below >= 0) possibleRanks.push(below);
            if (above <= 13) possibleRanks.push(above);
            const cardIsWild = isWild(card, round);
            if (!cardIsWild) {
                if (card.suit !== runSuit) return false;
                const cardIdx = rankOrder.indexOf(card.rank);
                const normalizedIdx = (cardIdx === 0 && maxIdx === 13) ? 13 : cardIdx;
                return possibleRanks.includes(normalizedIdx);
            } else {
                return possibleRanks.some(idx => {
                    const rank = (idx === 13) ? 'A' : rankOrder[idx];
                    return !!rank && !!runSuit;
                });
            }
        }
        function isValidSet(cards, round) {
            if (cards.length < 3) return false;
            const markedCards = cards.map(c => ({...c, isWildForRound: isWild(c, round)}));
            const nonWilds = markedCards.filter(c => !c.isWildForRound);
            if (nonWilds.length === 0) return false;
            const rank = nonWilds[0].rank;
            return nonWilds.every(c => c.rank === rank);
        }
        function assignWildsInSet(meld, round) {
            const result = meld.map(c => ({...c}));
            const nonWilds = result.filter(c => !isWild(c, round));
            if (nonWilds.length === 0) return result;
            const setRank = nonWilds[0].rank;
            const usedSuits = new Set(nonWilds.map(c => c.suit));
            result.forEach(c => {
                if (isWild(c, round) && c.representsCard) {
                    const match = c.representsCard.match(/([â™¥â™¦â™£â™ ])$/);
                    if (match) usedSuits.add(match[1]);
                }
            });
            const availableSuits = SUITS.filter(s => !usedSuits.has(s));
            let suitIndex = 0;
            result.forEach(card => {
                if (isWild(card, round) && !card.representsCard) {
                    let suit;
                    if (suitIndex < availableSuits.length) {
                        suit = availableSuits[suitIndex];
                        suitIndex++;
                    } else {
                        suit = SUITS[Math.floor(Math.random() * SUITS.length)];
                    }
                    card.representsCard = `${setRank}${suit}`;
                }
            });
            return result;
        }
        function getMeldType(meld, round) {
            const meldWithWilds = meld.map(c => ({
                ...c,
                isWildForRound: isWild(c, round)
            }));
            const canBeSet = isValidSet(meldWithWilds, round);
            const canBeRun = isValidRun(meldWithWilds, round);
            return { canBeSet, canBeRun, meldWithWilds };
        }
        function getPossibleMeldInterpretations(cards, round) {
            const MAX_SET_COMBINATIONS = 5;
            const MAX_EXTENSION_OPTIONS = 3;
            const MAX_ACE_HIGH_OPTIONS = 2;
            const options = [];
            const markedCards = cards.map(c => ({ ...c, isWildForRound: isWild(c, round) }));
            const nonWilds = markedCards.filter(c => !c.isWildForRound);
            const wilds = markedCards.filter(c => c.isWildForRound);
            if (nonWilds.length === 0) {
                return { allWilds: true, options: [] };
            }
            const { canBeSet, canBeRun } = getMeldType(cards, round);
            if (canBeSet && nonWilds.length > 0) {
                const setRank = nonWilds[0].rank;
                options.push({
                    type: 'set',
                    rank: setRank,
                    display: `Set of ${setRank}s`,
                    assignments: {},
                    needsAutoAssignment: wilds.length > 0
                });
            }
            if (canBeRun && nonWilds.length > 0) {
                const suit = nonWilds[0].suit;
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
                const hasAce = nonWildRanks.includes(0);
                const aceHighOptions = [];
                const aceLowOptions = [];
                if (wilds.length > 0) {
                    const minRank = nonWildRanks[0];
                    const maxRank = nonWildRanks[nonWildRanks.length - 1];
                    const span = maxRank - minRank + 1;
                    const gapsNeeded = span - nonWildRanks.length;
                    const wildsAvailable = wilds.length;
                    const allRanks = [];
                    for (let i = 0; i < nonWildRanks.length - 1; i++) {
                        allRanks.push(nonWildRanks[i]);
                        for (let gap = nonWildRanks[i] + 1; gap < nonWildRanks[i + 1]; gap++) {
                            allRanks.push(gap);
                        }
                    }
                    allRanks.push(nonWildRanks[nonWildRanks.length - 1]);
                    const wildsLeft = wildsAvailable - (allRanks.length - nonWildRanks.length);
                    const extensionOptions = [];
                    for (let extendLow = 0; extendLow <= wildsLeft && extendLow <= allRanks[0]; extendLow++) {
                        const extendHigh = wildsLeft - extendLow;
                        if (extendHigh >= 0 && allRanks[allRanks.length - 1] + extendHigh <= 12) {
                            const runRanks = [];
                            for (let i = allRanks[0] - extendLow; i < allRanks[0]; i++) runRanks.push(i);
                            runRanks.push(...allRanks);
                            for (let i = allRanks[allRanks.length - 1] + 1; i <= allRanks[allRanks.length - 1] + extendHigh; i++) runRanks.push(i);
                            extensionOptions.push(runRanks);
                        }
                    }
                    const shouldConsiderAceHigh = (hasAce && maxRank >= 10) || (maxRank >= 11 && wildsLeft > 0);
                    if (shouldConsiderAceHigh) {
                        const ranksAceHigh = nonWildRanks.filter(r => r !== 0).concat([13]).sort((a, b) => a - b);
                        const aceHighAllRanks = [];
                        for (let i = 0; i < ranksAceHigh.length - 1; i++) {
                            aceHighAllRanks.push(ranksAceHigh[i]);
                            for (let gap = ranksAceHigh[i] + 1; gap < ranksAceHigh[i + 1]; gap++) {
                                aceHighAllRanks.push(gap);
                            }
                        }
                        aceHighAllRanks.push(ranksAceHigh[ranksAceHigh.length - 1]);
                        const wildsLeftAceHigh = wildsAvailable - (aceHighAllRanks.length - ranksAceHigh.length);
                        if (wildsLeftAceHigh >= 0) {
                            for (let extendLow = 0; extendLow <= wildsLeftAceHigh && extendLow <= aceHighAllRanks[0]; extendLow++) {
                                const extendHigh = wildsLeftAceHigh - extendLow;
                                if (extendHigh >= 0 && aceHighAllRanks[aceHighAllRanks.length - 1] + extendHigh <= 13) {
                                    const runRanks = [];
                                    for (let i = aceHighAllRanks[0] - extendLow; i < aceHighAllRanks[0]; i++) runRanks.push(i);
                                    runRanks.push(...aceHighAllRanks);
                                    for (let i = aceHighAllRanks[aceHighAllRanks.length - 1] + 1; i <= aceHighAllRanks[aceHighAllRanks.length - 1] + extendHigh; i++) runRanks.push(i);
                                    aceHighOptions.push(runRanks);
                                }
                            }
                        }
                    }
                    const allRunOptions = [...extensionOptions.slice(0, MAX_EXTENSION_OPTIONS), ...aceHighOptions.slice(0, MAX_ACE_HIGH_OPTIONS)];
                    for (const runRanks of allRunOptions) {
                        const display = [];
                        const assignments = {};
                        const cardIds = [];
                        const normalCardsByRank = new Map();
                        nonWilds.forEach(c => {
                            const rankIdx = c.rank === 'A' && runRanks.includes(13) ? 13 : rankOrder.indexOf(c.rank);
                            normalCardsByRank.set(rankIdx, c);
                        });
                        let wildIdx = 0;
                        runRanks.forEach(r => {
                            const rank = r === 13 ? 'A' : rankOrder[r];
                            if (normalCardsByRank.has(r)) {
                                const originalCard = normalCardsByRank.get(r);
                                display.push(`${originalCard.rank}${originalCard.suit}`);
                                cardIds.push(originalCard.id);
                            } else if (wildIdx < wilds.length) {
                                display.push(`${rank}${suit}`);
                                assignments[wilds[wildIdx].id] = `${rank}${suit}`;
                                cardIds.push(wilds[wildIdx].id);
                                wildIdx++;
                            }
                        });
                        options.push({
                            type: 'run',
                            display: display,
                            assignments: assignments,
                            cardIds: cardIds
                        });
                    }
                } else {
                    options.push({
                        type: 'run',
                        display: nonWilds.map(c => `${c.rank}${c.suit}`),
                        assignments: {},
                        cardIds: nonWilds.map(c => c.id)
                    });
                }
            }
            return { allWilds: false, options: options };
        }
        function calculateScore(cards) {
            return cards.reduce((sum, card) => {
                if (card.rank === 'JOKER') return sum + 20;
                return sum + CARD_VALUES[card.rank];
            }, 0);
        }
        function makeAIDecision(hand, discardPile, round, deckCount, justDrawnCard = null) {
            const topDiscard = discardPile[discardPile.length - 1];
            let drawFromDiscard = false;
            if (topDiscard) {
                if (isWild(topDiscard, round)) {
                    drawFromDiscard = true;
                } else {
                    const matchingCards = hand.filter(c => c.rank === topDiscard.rank);
                    const wildCards = hand.filter(c => isWild(c, round));
                    if (matchingCards.length >= 2 || (matchingCards.length >= 1 && wildCards.length >= 1)) {
                        drawFromDiscard = true;
                    } else {
                        const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                        const discardRankIdx = rankOrder.indexOf(topDiscard.rank);
                        const discardSuit = topDiscard.suit;
                        const nearbyCards = hand.filter(c => {
                            if (isWild(c, round)) return true;
                            if (c.suit !== discardSuit) return false;
                            const cardRankIdx = rankOrder.indexOf(c.rank);
                            const distance = Math.abs(cardRankIdx - discardRankIdx);
                            return distance <= 2 && distance > 0;
                        });
                        if (nearbyCards.length >= 2) {
                            drawFromDiscard = true;
                        } else if (nearbyCards.length >= 1) {
                            const adjacentCards = hand.filter(c => {
                                if (isWild(c, round)) return false;
                                if (c.suit !== discardSuit) return false;
                                const cardRankIdx = rankOrder.indexOf(c.rank);
                                return Math.abs(cardRankIdx - discardRankIdx) === 1;
                            });
                            if (adjacentCards.length >= 1) {
                                drawFromDiscard = true;
                            }
                        }
                    }
                }
            }
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            let worstCardIndex = -1;
            let worstScore = -Infinity;
            hand.forEach((card, index) => {
                if (justDrawnCard && card.id === justDrawnCard.id) {
                    return;
                }
                if (isWild(card, round)) {
                    return;
                }
                let score = 0;
                const pointValue = CARD_VALUES[card.rank] || 0;
                score -= pointValue * 2;
                const sameRankCount = hand.filter(c => c.rank === card.rank && c.id !== card.id).length;
                if (sameRankCount >= 2) {
                    score += 50;
                } else if (sameRankCount === 1) {
                    score += 20;
                }
                const cardRankIdx = rankOrder.indexOf(card.rank);
                const sameSuitNearby = hand.filter(c => {
                    if (c.suit !== card.suit || c.id === card.id) return false;
                    if (isWild(c, round)) return true;
                    const otherRankIdx = rankOrder.indexOf(c.rank);
                    const distance = Math.abs(otherRankIdx - cardRankIdx);
                    return distance <= 2 && distance > 0;
                }).length;
                if (sameSuitNearby >= 2) {
                    score += 40;
                } else if (sameSuitNearby === 1) {
                    score += 15;
                }
                if (cardRankIdx >= 3 && cardRankIdx <= 9) {
                    score += 5;
                }
                if (score < worstScore) {
                    worstScore = score;
                    worstCardIndex = index;
                }
            });
            if (worstCardIndex === -1) {
                worstCardIndex = hand.findIndex(card => !isWild(card, round) && (!justDrawnCard || card.id !== justDrawnCard.id));
                if (worstCardIndex === -1) {
                    worstCardIndex = hand.findIndex(card => !justDrawnCard || card.id !== justDrawnCard.id);
                    if (worstCardIndex === -1) {
                        worstCardIndex = hand.length - 1;
                    }
                }
            }
            return { drawFromDiscard, discardIndex: worstCardIndex };
        }
        function findBestMelds(hand, round, reserveForDiscard = true) {
            const markedHand = hand.map(card => ({ ...card, isWildForRound: isWild(card, round) }));
            function findAllPossibleMelds(cards) {
                const possibleMelds = [];
                for (let size = 3; size <= cards.length; size++) {
                    const combos = combinations(cards, size);
                    for (let combo of combos) {
                        if (isValidSet(combo, round) || isValidRun(combo, round)) {
                            possibleMelds.push(combo);
                        }
                    }
                }
                return possibleMelds;
            }
            function combinations(array, size) {
                if (size > array.length) return [];
                if (size === array.length) return [array];
                if (size === 1) return array.map(item => [item]);
                const combos = [];
                for (let i = 0; i <= array.length - size; i++) {
                    const head = array[i];
                    const tailCombos = combinations(array.slice(i + 1), size - 1);
                    for (let tail of tailCombos) {
                        combos.push([head, ...tail]);
                    }
                }
                return combos;
            }
            function findBestMeldCombination(cards, allMelds) {
                let bestSolution = { melds: [], cardsUsed: 0, remainingPoints: Infinity };
                function tryMelds(currentMelds, usedCards, meldIndex) {
                    const cardsUsed = usedCards.size;
                    const remaining = cards.filter(c => !usedCards.has(c.id));
                    const remainingPoints = remaining.reduce((sum, c) => sum + (CARD_VALUES[c.rank] || 0), 0);
                    if (cardsUsed > bestSolution.cardsUsed ||
                        (cardsUsed === bestSolution.cardsUsed && remainingPoints < bestSolution.remainingPoints)) {
                        bestSolution = {
                            melds: [...currentMelds],
                            cardsUsed,
                            remainingPoints,
                            remaining
                        };
                    }
                    for (let i = meldIndex; i < allMelds.length; i++) {
                        const meld = allMelds[i];
                        const overlaps = meld.some(card => usedCards.has(card.id));
                        if (overlaps) continue;
                        const newUsedCards = new Set(usedCards);
                        meld.forEach(card => newUsedCards.add(card.id));
                        tryMelds([...currentMelds, meld], newUsedCards, i + 1);
                    }
                }
                tryMelds([], new Set(), 0);
                return bestSolution;
            }
            const allPossibleMelds = findAllPossibleMelds(markedHand);
            let bestCombination = findBestMeldCombination(markedHand, allPossibleMelds);
            if (reserveForDiscard && bestCombination.remaining.length === 0 && bestCombination.melds.length > 0) {
                let smallestMeldIdx = 0;
                let smallestSize = bestCombination.melds[0].length;
                for (let i = 1; i < bestCombination.melds.length; i++) {
                    if (bestCombination.melds[i].length < smallestSize) {
                        smallestSize = bestCombination.melds[i].length;
                        smallestMeldIdx = i;
                    }
                }
                const smallestMeld = [...bestCombination.melds[smallestMeldIdx]];
                let lowestValueIdx = -1;
                let lowestValue = Infinity;
                for (let i = 0; i < smallestMeld.length; i++) {
                    const card = smallestMeld[i];
                    if (!isWild(card, round)) {
                        const value = CARD_VALUES[card.rank] || 0;
                        if (value < lowestValue) {
                            lowestValue = value;
                            lowestValueIdx = i;
                        }
                    }
                }
                if (lowestValueIdx === -1) {
                    lowestValueIdx = smallestMeld.length - 1;
                }
                const removedCard = smallestMeld.splice(lowestValueIdx, 1)[0];
                const updatedMelds = [...bestCombination.melds];
                if (smallestMeld.length < 3) {
                    bestCombination.remaining = [...bestCombination.remaining, ...smallestMeld, removedCard];
                    updatedMelds.splice(smallestMeldIdx, 1);
                } else {
                    updatedMelds[smallestMeldIdx] = smallestMeld;
                    bestCombination.remaining = [...bestCombination.remaining, removedCard];
                }
                bestCombination = {
                    ...bestCombination,
                    melds: updatedMelds
                };
            }
            const finalMelds = bestCombination.melds.map(meld => {
                const hasWilds = meld.some(card => isWild(card, round));
                if (hasWilds) {
                    if (isValidRun(meld, round)) {
                        const meldWithAssignedWilds = assignJokersInRun(meld, round);
                        return sortMeld(meldWithAssignedWilds, round);
                    } else if (isValidSet(meld, round)) {
                        const meldWithAssignedWilds = assignWildsInSet(meld, round);
                        return sortMeld(meldWithAssignedWilds, round);
                    }
                }
                return sortMeld(meld, round);
            });
            return {
                melds: finalMelds,
                remaining: bestCombination.remaining || markedHand
            };
        }
        function Celebration({ playerName, onClose }) {
            useEffect(() => {
                const timer = setTimeout(onClose, 3000);
                return () => clearTimeout(timer);
            }, []);
            return (
                <div className="celebration-overlay">
                    <div className="celebration-content">
                        <h2>ðŸ’° PAY ME! ðŸ’°</h2>
                        <div className="winner-name">{playerName}</div>
                        <div className="coins">ðŸ’µðŸ’µðŸ’µ</div>
                        <p style={{fontSize: '20px', color: '#666'}}>Everyone pays up!</p>
                    </div>
                </div>
            );
        }
        function ScoreDetailsModal({ player, round, onClose }) {
            if (!player) return null;
            return (
                <div className="celebration-overlay" onClick={onClose}>
                    <div className="score-details-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="score-details-header">
                            <h2>{player.avatar} {player.name} - Score History</h2>
                            <button onClick={onClose} style={{fontSize: '24px', padding: '5px 15px'}}>Ã—</button>
                        </div>
                        <div className="score-details-content">
                            {player.roundHistory && player.roundHistory.length > 0 ? (
                                <table className="score-detail-table">
                                    <thead>
                                        <tr>
                                            <th>Round</th>
                                            <th>Melds</th>
                                            <th>Remaining</th>
                                            <th>Points</th>
                                            <th>Total</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {player.roundHistory.map((roundData, idx) => (
                                            <tr key={idx} className={roundData.wasWinner ? 'winner-round' : ''}>
                                                <td>
                                                    <strong>Round {roundData.round}</strong>
                                                    {roundData.wasWinner && <span style={{marginLeft: '5px'}}>ðŸ†</span>}
                                                </td>
                                                <td>
                                                    {roundData.melds.length > 0 ? (
                                                        roundData.melds.map((meld, meldIdx) => (
                                                            <div key={meldIdx} className="mini-cards" style={{marginBottom: '4px'}}>
                                                                {meld.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, roundData.round)}} />
                                                                ))}
                                                            </div>
                                                        ))
                                                    ) : (
                                                        <span style={{color: '#999'}}>None</span>
                                                    )}
                                                </td>
                                                <td>
                                                    {roundData.remainingCards.length > 0 ? (
                                                        <div className="mini-cards">
                                                            {roundData.remainingCards.filter(c => !c.addedBy).map((card, cardIdx) => (
                                                                <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, roundData.round)}} />
                                                            ))}
                                                        </div>
                                                    ) : (
                                                        <span style={{color: '#28a745', fontWeight: 'bold'}}>None</span>
                                                    )}
                                                    {roundData.playedOnCards && roundData.playedOnCards.length > 0 && (
                                                        <>
                                                            <div style={{fontSize: '11px', color: '#666', marginTop: '4px'}}>Played off:</div>
                                                            <div className="mini-cards" style={{opacity: 0.7}}>
                                                                {roundData.playedOnCards.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, roundData.round)}} />
                                                                ))}
                                                            </div>
                                                        </>
                                                    )}
                                                </td>
                                                <td>
                                                    <strong style={{color: roundData.roundScore === 0 ? '#28a745' : '#dc3545'}}>
                                                        {roundData.roundScore === 0 ? '0' : `+${roundData.roundScore}`}
                                                    </strong>
                                                </td>
                                                <td><strong>{roundData.runningScore}</strong></td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            ) : (
                                <p style={{textAlign: 'center', color: '#666', padding: '20px'}}>
                                    No rounds completed yet.
                                </p>
                            )}
                        </div>
                    </div>
                </div>
            );
        }
        function MiniCard({ card, isWinnerHand }) {
            if (isWinnerHand) {
                return <WinnerHandCard card={card} showOriginalTag={!card.addedBy} />;
            }
            const isJoker = card.rank === 'JOKER';
            const representsCard = card.representsCard;
            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            const representedSuit = representsCard ? representsCard.slice(-1) : null;
            const representedIsRed = representedSuit === 'â™¥' || representedSuit === 'â™¦';
            if (isJoker) {
                return (
                    <div
                        className={`mini-card ${card.isWildForRound ? 'wild' : ''}`}
                        title={representsCard ? `Represents ${representsCard}` : ''}
                        style={{
                            position: 'relative',
                            display: 'inline-flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '0'
                        }}
                    >
                        <div style={{
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '38px',
                            lineHeight: '1'
                        }}>ðŸƒ</div>
                        {representsCard && (
                            <div style={{
                                position: 'absolute',
                                bottom: '1px',
                                right: '1px',
                                fontSize: '7px',
                                fontWeight: 'bold',
                                color: representedIsRed ? '#e74c3c' : '#000',
                                background: 'rgba(255,255,255,0.95)',
                                padding: '0px 2px',
                                borderRadius: '2px',
                                zIndex: 10,
                                border: '0.5px solid #b8860b',
                                lineHeight: '1.1'
                            }}>
                                ={representsCard}
                            </div>
                        )}
                    </div>
                );
            }
            return (
                <div
                    className={`mini-card ${isRed ? 'red' : 'black'} ${card.isWildForRound ? 'wild' : ''}`}
                    title={representsCard ? `Represents ${representsCard}` : ''}
                    style={{
                        position: 'relative',
                        display: 'inline-flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '2px'
                    }}
                >
                    <div style={{fontSize: '12px', fontWeight: 'bold', lineHeight: '1'}}>{card.rank}</div>
                    <div style={{fontSize: '14px', lineHeight: '1'}}>{card.suit}</div>
                    {representsCard && (
                        <div style={{
                            position: 'absolute',
                            bottom: '1px',
                            fontSize: '8px',
                            fontWeight: 'bold',
                            color: representedIsRed ? '#e74c3c' : '#000',
                            opacity: 0.8
                        }}>
                            ={representsCard}
                        </div>
                    )}
                </div>
            );
        }
        function WinnerHandCard({ card, showOriginalTag = true }) {
            const isJoker = card.rank === 'JOKER';
            const isFaceCard = ['J', 'Q', 'K'].includes(card.rank);
            const isWildCard = card.isWildForRound && !isJoker;
            const representsCard = card.representsCard;
            const addedBy = card.addedBy;
            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            const representedSuit = representsCard ? representsCard.slice(-1) : null;
            const representedIsRed = representedSuit === 'â™¥' || representedSuit === 'â™¦';
            const className = `winner-hand-card ${isFaceCard ? 'face-card' : ''} ${isRed ? 'red' : 'black'} ${card.isWildForRound ? 'wild' : ''}`;
            const getFaceCardName = (rank) => {
                if (rank === 'J') return 'JACK';
                if (rank === 'Q') return 'QUEEN';
                if (rank === 'K') return 'KING';
                return '';
            };
            const getSuitPattern = (rank, suit) => {
                const patterns = {
                    '2': [{ top: '25%', left: '50%' }, { top: '75%', left: '50%', rotate: 180 }],
                    '3': [{ top: '19%', left: '50%' }, { top: '50%', left: '50%' }, { top: '80%', left: '50%', rotate: 180 }],
                    '4': [
                        { top: '25%', left: '35%' }, { top: '25%', left: '65%' },
                        { top: '75%', left: '35%', rotate: 180 }, { top: '75%', left: '65%', rotate: 180 }
                    ],
                    '5': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '6': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '7': [
                        { top: '17%', left: '35%' }, { top: '17%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '83%', left: '35%', rotate: 180 }, { top: '83%', left: '65%', rotate: 180 }
                    ],
                    '8': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '65%', left: '50%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '9': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '10': [
                        { top: '6%', left: '35%' }, { top: '6%', left: '65%' },
                        { top: '19%', left: '50%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '81%', left: '50%', rotate: 180 },
                        { top: '94%', left: '35%', rotate: 180 }, { top: '94%', left: '65%', rotate: 180 }
                    ],
                    'A': [{ top: '50%', left: '50%' }]
                };
                return patterns[rank] || [];
            };
            const getFaceCardUnicode = (rank, suit) => {
                const cards = {
                    'Jâ™ ': 'ðŸ‚«', 'Jâ™¥': 'ðŸ‚»', 'Jâ™¦': 'ðŸƒ‹', 'Jâ™£': 'ðŸƒ›',
                    'Qâ™ ': 'ðŸ‚­', 'Qâ™¥': 'ðŸ‚½', 'Qâ™¦': 'ðŸƒ', 'Qâ™£': 'ðŸƒ',
                    'Kâ™ ': 'ðŸ‚®', 'Kâ™¥': 'ðŸ‚¾', 'Kâ™¦': 'ðŸƒŽ', 'Kâ™£': 'ðŸƒž'
                };
                return cards[`${rank}${suit}`] || 'ðŸ‚ ';
            };
            return (
                <div className={className} style={{
                    boxShadow: addedBy ? '0 0 0 3px #28a745' : '0 0 0 2px rgba(30, 60, 114, 0.2)',
                    position: 'relative'
                }}>
                    <div className="card-decorative-border"></div>
                    {}
                    {showOriginalTag && !addedBy && (
                        <div style={{
                            position: 'absolute',
                            top: '-8px',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            background: '#1e3c72',
                            color: 'white',
                            fontSize: '8px',
                            padding: '2px 6px',
                            borderRadius: '3px',
                            fontWeight: 'bold',
                            whiteSpace: 'nowrap',
                            zIndex: 10,
                            boxShadow: '0 1px 3px rgba(0,0,0,0.3)'
                        }}>
                            ORIGINAL
                        </div>
                    )}
                    {}
                    {addedBy && (
                        <div style={{
                            position: 'absolute',
                            top: '4px',
                            right: '4px',
                            fontSize: '14px',
                            background: 'rgba(255,255,255,0.9)',
                            borderRadius: '50%',
                            width: '20px',
                            height: '20px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            border: '2px solid #28a745',
                            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                            zIndex: 10
                        }}>
                            {addedBy}
                        </div>
                    )}
                    {!isJoker && (
                        <>
                            {}
                            {!isFaceCard && (
                                <>
                                    <div className="card-corner top-left">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                    <div className="card-corner bottom-right">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                </>
                            )}
                            {}
                            {isFaceCard ? (
                                <div style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}>
                                    <div style={{
                                        fontSize: 'clamp(68px, 11.25vw, 128px)',
                                        lineHeight: '1'
                                    }}>
                                        {getFaceCardUnicode(card.rank, card.suit)}
                                    </div>
                                </div>
                            ) : (
                                <div style={{ position: 'absolute', top: '0', left: '0', width: '100%', height: '100%' }}>
                                    {getSuitPattern(card.rank, card.suit).map((pos, idx) => (
                                        <div
                                            key={idx}
                                            style={{
                                                position: 'absolute',
                                                top: pos.top,
                                                left: pos.left,
                                                transform: `translate(-50%, -50%) ${pos.rotate ? `rotate(${pos.rotate}deg)` : ''}`,
                                                fontSize: 'clamp(12px, 2.5vw, 20px)',
                                                lineHeight: '1'
                                            }}
                                        >
                                            {card.suit}
                                        </div>
                                    ))}
                                </div>
                            )}
                            {representsCard && isWildCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: '16px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: '9px',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.9)',
                                    padding: '2px 5px',
                                    borderRadius: '3px',
                                    border: '1px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 11
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                    {isJoker && (
                        <>
                            <div style={{
                                position: 'absolute',
                                top: '3px',
                                left: '3px',
                                right: '3px',
                                bottom: '3px',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: 'clamp(60px, 9vw, 110px)',
                                lineHeight: '1'
                            }}>
                                ðŸƒ
                            </div>
                            {representsCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: 'clamp(6px, 1vw, 12px)',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: 'clamp(9px, 1.2vw, 12px)',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.95)',
                                    padding: '2px 5px',
                                    borderRadius: '3px',
                                    border: '1px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 10,
                                    whiteSpace: 'nowrap'
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }
        function Card({ card, onClick, onDoubleClick, selected, disabled, inMeld, draggable, onDragStart, onDragOver, onDrop, onDragEnd, isDragging, onTouchStart, onTouchMove, onTouchEnd }) {
            const isJoker = card.rank === 'JOKER';
            const isFaceCard = ['J', 'Q', 'K'].includes(card.rank);
            const isWildCard = card.isWildForRound && !isJoker;
            const representsCard = card.representsCard;
            const addedBy = card.addedBy;
            const className = `card ${isFaceCard ? 'face-card' : ''} ${card.isRed ? 'red' : 'black'} ${selected ? 'selected' : ''} ${disabled ? 'disabled' : ''} ${card.isWildForRound ? 'wild' : ''} ${inMeld ? 'in-meld' : ''} ${isDragging ? 'dragging' : ''}`;
            const getFaceCardName = (rank) => {
                if (rank === 'J') return 'JACK';
                if (rank === 'Q') return 'QUEEN';
                if (rank === 'K') return 'KING';
                return '';
            };
            const getSuitPattern = (rank, suit) => {
                const patterns = {
                    '2': [{ top: '25%', left: '50%' }, { top: '75%', left: '50%', rotate: 180 }],
                    '3': [{ top: '19%', left: '50%' }, { top: '50%', left: '50%' }, { top: '80%', left: '50%', rotate: 180 }],
                    '4': [
                        { top: '25%', left: '35%' }, { top: '25%', left: '65%' },
                        { top: '75%', left: '35%', rotate: 180 }, { top: '75%', left: '65%', rotate: 180 }
                    ],
                    '5': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '6': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '7': [
                        { top: '17%', left: '35%' }, { top: '17%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '83%', left: '35%', rotate: 180 }, { top: '83%', left: '65%', rotate: 180 }
                    ],
                    '8': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '65%', left: '50%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '9': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '10': [
                        { top: '6%', left: '35%' }, { top: '6%', left: '65%' },
                        { top: '19%', left: '50%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '81%', left: '50%', rotate: 180 },
                        { top: '94%', left: '35%', rotate: 180 }, { top: '94%', left: '65%', rotate: 180 }
                    ],
                    'A': [{ top: '50%', left: '50%' }]
                };
                return patterns[rank] || [];
            };
            const getFaceCardUnicode = (rank, suit) => {
                const cards = {
                    'Jâ™ ': 'ðŸ‚«', 'Jâ™¥': 'ðŸ‚»', 'Jâ™¦': 'ðŸƒ‹', 'Jâ™£': 'ðŸƒ›',
                    'Qâ™ ': 'ðŸ‚­', 'Qâ™¥': 'ðŸ‚½', 'Qâ™¦': 'ðŸƒ', 'Qâ™£': 'ðŸƒ',
                    'Kâ™ ': 'ðŸ‚®', 'Kâ™¥': 'ðŸ‚¾', 'Kâ™¦': 'ðŸƒŽ', 'Kâ™£': 'ðŸƒž'
                };
                return cards[`${rank}${suit}`] || 'ðŸ‚ ';
            };
            return (
                <div
                    className={className}
                    onClick={onClick}
                    onDoubleClick={onDoubleClick}
                    draggable={draggable}
                    onDragStart={onDragStart}
                    onDragOver={onDragOver}
                    onDrop={onDrop}
                    onDragEnd={onDragEnd}
                    onTouchStart={onTouchStart}
                    onTouchMove={onTouchMove}
                    onTouchEnd={onTouchEnd}
                >
                    <div className="card-decorative-border"></div>
                    {}
                    {addedBy && (
                        <div style={{
                            position: 'absolute',
                            top: '5px',
                            right: '5px',
                            fontSize: '16px',
                            background: 'rgba(255,255,255,0.9)',
                            borderRadius: '50%',
                            width: '24px',
                            height: '24px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            border: '2px solid #28a745',
                            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                            zIndex: 10
                        }}>
                            {addedBy}
                        </div>
                    )}
                    {!isJoker && (
                        <>
                            {}
                            {!isFaceCard && (
                                <>
                                    <div className="card-corner top-left">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                    <div className="card-corner bottom-right">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                </>
                            )}
                            {}
                            {isFaceCard ? (
                                <div style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}>
                                    {}
                                    <div style={{
                                        fontSize: 'clamp(105px, 13.5vw, 165px)',
                                        lineHeight: '1'
                                    }}>
                                        {getFaceCardUnicode(card.rank, card.suit)}
                                    </div>
                                </div>
                            ) : (
                                <div style={{ position: 'absolute', top: '0', left: '0', width: '100%', height: '100%' }}>
                                    {getSuitPattern(card.rank, card.suit).map((pos, idx) => (
                                        <div
                                            key={idx}
                                            style={{
                                                position: 'absolute',
                                                top: pos.top,
                                                left: pos.left,
                                                transform: `translate(-50%, -50%) ${pos.rotate ? `rotate(${pos.rotate}deg)` : ''}`,
                                                fontSize: 'clamp(16px, 3.2vw, 26px)',
                                                lineHeight: '1'
                                            }}
                                        >
                                            {card.suit}
                                        </div>
                                    ))}
                                </div>
                            )}
                            {}
                            {representsCard && isWildCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: '20px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: '11px',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.9)',
                                    padding: '2px 6px',
                                    borderRadius: '3px',
                                    border: '1px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 11
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                    {isJoker && (
                        <>
                            <div style={{
                                position: 'absolute',
                                top: '4px',
                                left: '4px',
                                right: '4px',
                                bottom: '4px',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: 'clamp(85px, 11vw, 145px)',
                                lineHeight: '1'
                            }}>
                                ðŸƒ
                            </div>
                            {representsCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: 'clamp(18px, 2vw, 25px)',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: 'clamp(10px, 1.2vw, 13px)',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.95)',
                                    padding: '3px 6px',
                                    borderRadius: '4px',
                                    border: '1.5px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 10,
                                    whiteSpace: 'nowrap'
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }
        function GameSetup({ onStart }) {
            const allPlayerNames = AI_CHARACTERS.map(c => c.name);
            const [playerName, setPlayerName] = useState(allPlayerNames[0]);
            const [aiCount, setAiCount] = useState(3);
            return (
                <div className="setup-screen">
                    <h2>ðŸ’° Pay Me - Game Setup</h2>
                    <div className="form-group">
                        <label>Your Name:</label>
                        <select value={playerName} onChange={(e) => setPlayerName(e.target.value)}>
                            {allPlayerNames.map(name => <option key={name} value={name}>{name}</option>)}
                        </select>
                    </div>
                    <div className="form-group">
                        <label>Number of AI Opponents (1-7):</label>
                        <select value={aiCount} onChange={(e) => setAiCount(parseInt(e.target.value))}>
                            {[1,2,3,4,5,6,7].map(n => <option key={n} value={n}>{n} AI player{n > 1 ? 's' : ''}</option>)}
                        </select>
                    </div>
                    <button onClick={() => onStart({ playerName, aiCount })}>Start Game</button>
                </div>
            );
        }
        function PayMeGame() {
            const [gameStarted, setGameStarted] = useState(false);
            const [players, setPlayers] = useState([]);
            const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
            const [round, setRound] = useState(1);
            const [deck, setDeck] = useState([]);
            const [discardPile, setDiscardPile] = useState([]);
            const [selectedCard, setSelectedCard] = useState(null);
            const [selectedCardForWinner, setSelectedCardForWinner] = useState(null);
            const [message, setMessage] = useState('');
            const [aiDrawHighlight, setAiDrawHighlight] = useState(null);
const [gamePhase, setGamePhase] = useState('draw');
        const [isRoundTransitioning, setIsRoundTransitioning] = useState(false);
            const [roundWinner, setRoundWinner] = useState(null);
            const [winnerMelds, setWinnerMelds] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [dealerIndex, setDealerIndex] = useState(0);
            const [buildingPayMe, setBuildingPayMe] = useState(false);
            const [playerMelds, setPlayerMelds] = useState([]);
            const [currentMeld, setCurrentMeld] = useState([]);
            const [meldError, setMeldError] = useState('');
            const [showCelebration, setShowCelebration] = useState(false);
            const [isPaused, setIsPaused] = useState(false);
            const isPausedRef = useRef(false);
            const [sidePanelCollapsed, setSidePanelCollapsed] = useState(false);
            const [celebrationName, setCelebrationName] = useState('');
            const [scoreDetailsPlayer, setScoreDetailsPlayer] = useState(null);
            const [showScoreDetails, setShowScoreDetails] = useState(false);
            const [flyingCard, setFlyingCard] = useState(null);
            const [draggedCardIndex, setDraggedCardIndex] = useState(null);
            const [dropTargetIndex, setDropTargetIndex] = useState(null);
            const [hoveredWinnerMeldIndex, setHoveredWinnerMeldIndex] = useState(null);
            const roundTransitionTimeoutRef = useRef(null);
            const hoveredWinnerMeldRef = React.useRef(null);
            const draggedCardRectRef = React.useRef(null);
            const nextFinalTurnActionRef = React.useRef(null);
            const timeoutRefs = React.useRef([]);
            const intervalRefs = React.useRef([]);
            const isDiscardingRef = React.useRef(false);
            const [flyingCardToWinner, setFlyingCardToWinner] = useState(null);
            const [showingAIMelds, setShowingAIMelds] = useState(false);
            const [aiResultsToShow, setAiResultsToShow] = useState(null);
            const [isDiscarding, setIsDiscarding] = useState(false);
            const [showingHumanFinalPlay, setShowingHumanFinalPlay] = useState(false);
            const [humanFinalPlayResults, setHumanFinalPlayResults] = useState(null);
            const [allFinalPlaysComplete, setAllFinalPlaysComplete] = useState(false);
            const [draggedMeldCardIndex, setDraggedMeldCardIndex] = useState(null);
            const [dropTargetMeldIndex, setDropTargetMeldIndex] = useState(null);
            const [showDealingAnimation, setShowDealingAnimation] = useState(false);
            const [showDealerSelection, setShowDealerSelection] = useState(false);
            const [dealerSelectionStep, setDealerSelectionStep] = useState(0);
            const [dealerSelectionDeck, setDealerSelectionDeck] = useState([]);
            const [dealerSelectionDeckCount, setDealerSelectionDeckCount] = useState(1);
            const [pausedAfterPayMe, setPausedAfterPayMe] = useState(false);
            const [playersWhoHaveTakenFinalTurn, setPlayersWhoHaveTakenFinalTurn] = useState(new Set());
            const [showWildCardModal, setShowWildCardModal] = useState(false);
            const [wildCardToAssign, setWildCardToAssign] = useState(null);
            const [wildAssignmentCallback, setWildAssignmentCallback] = useState(null);
            const [winnerMeldWildPicker, setWinnerMeldWildPicker] = useState(null);
            const [cardBeingDroppedOnWinner, setCardBeingDroppedOnWinner] = useState(null);
            const [meldBuildingComplete, setMeldBuildingComplete] = useState(false);
            const [dealingInfo, setDealingInfo] = useState(null);
            const [showMeldPicker, setShowMeldPicker] = useState(false);
            const [meldPickerOptions, setMeldPickerOptions] = useState([]);
            const [meldPickerStep, setMeldPickerStep] = useState(1);
            const [meldPickerAllWilds, setMeldPickerAllWilds] = useState(false);
            const [meldPickerSelectedType, setMeldPickerSelectedType] = useState(null);
            const [meldPickerSelectedSuit, setMeldPickerSelectedSuit] = useState(null);
            const [pendingFinalizeAfterPick, setPendingFinalizeAfterPick] = useState(false);
            const [aiSpeed, setAiSpeed] = useState(3);
            const startGame = ({ playerName, aiCount }) => {
                const totalPlayers = aiCount + 1;
                const deckCount = totalPlayers <= 2 ? 1 : totalPlayers <= 5 ? 2 : 3;
                let initialDeck = [];
                for (let i = 0; i < deckCount; i++) {
                    initialDeck = initialDeck.concat(createDeck());
                }
                initialDeck = initialDeck.filter(card => card.rank !== 'JOKER');
                initialDeck = shuffle(initialDeck);
                const newPlayers = [
                    { id: 0, name: playerName, isAI: false, quarters: 13, hand: [], score: 0, melds: [], dealerCard: null, avatar: AI_CHARACTERS.find(c => c.name === playerName)?.avatar || "ðŸ‘¤", dialogue: "", roundHistory: [] }
                ];
                const availableCharacters = AI_CHARACTERS.filter(c => c.name !== playerName);
                const shuffledCharacters = shuffle([...availableCharacters]);
                for (let i = 0; i < aiCount; i++) {
                    const character = shuffledCharacters[i % availableCharacters.length];
                    newPlayers.push({
                        id: i + 1, name: character.name, avatar: character.avatar, character: character,
                        isAI: true, quarters: 13, hand: [], score: 0, melds: [], dealerCard: null,
                        dialogue: getDialogue(character, 'start'), roundHistory: []
                    });
                }
                setPlayers(newPlayers);
                setDealerSelectionDeck(initialDeck);
                setDealerSelectionDeckCount(deckCount);
                setShowDealerSelection(true);
                setDealerSelectionStep(0);
                setGameStarted(true);
                setMessage("Dealing cards to determine the dealer...");
                const timeoutId = setTimeout(() => dealDealerCards(newPlayers, initialDeck), 500);
                timeoutRefs.current.push(timeoutId);
            };
            const dealDealerCards = (playersToUpdate, deckToUse) => {
                let currentStep = 0;
                const dealNextCard = () => {
                    if (currentStep < playersToUpdate.length) {
                        const card = deckToUse.pop();
                        setPlayers(prev => {
                            const updated = [...prev];
                            updated[currentStep] = { ...updated[currentStep], dealerCard: card };
                            return updated;
                        });
                        setDealerSelectionStep(currentStep + 1);
                        currentStep++;
                        const timeoutId = setTimeout(dealNextCard, 500);
                        timeoutRefs.current.push(timeoutId);
                    } else {
                        const timeoutId = setTimeout(() => {
                            checkForDealerWinner(deckToUse);
                        }, 1000);
                        timeoutRefs.current.push(timeoutId);
                    }
                };
                dealNextCard();
            };
            const checkForDealerWinner = (currentDeck) => {
                setPlayers(currentPlayers => {
                    const playersWithCards = [];
                    currentPlayers.forEach((p, idx) => {
                        if (p.dealerCard) {
                            playersWithCards.push(idx);
                        }
                    });
                    let highestValue = -1;
                    const tiedPlayers = [];
                    playersWithCards.forEach(idx => {
                        const p = currentPlayers[idx];
                        const cardValue = CARD_VALUES[p.dealerCard.rank] || 20;
                        if (cardValue > highestValue) {
                            highestValue = cardValue;
                            tiedPlayers.length = 0;
                            tiedPlayers.push(idx);
                        } else if (cardValue === highestValue) {
                            tiedPlayers.push(idx);
                        }
                    });
                    if (tiedPlayers.length === 1) {
                        const dealerIdx = tiedPlayers[0];
                        setDealerIndex(dealerIdx);
                        setMessage(`${currentPlayers[dealerIdx].name} draws ${currentPlayers[dealerIdx].dealerCard.rank}${currentPlayers[dealerIdx].dealerCard.suit} - highest card! They are the dealer!`);
                        const timeoutId = setTimeout(() => {
                            setShowDealerSelection(false);
                            startRound(1, currentPlayers, dealerSelectionDeckCount, dealerIdx);
                        }, 1000);
                        timeoutRefs.current.push(timeoutId);
                    } else {
                        setMessage(`Tie between ${tiedPlayers.map(idx => currentPlayers[idx].name).join(' and ')}! Dealing new cards...`);
                        const timeoutId1 = setTimeout(() => {
                            setPlayers(prev => {
                                const updated = prev.map(p => ({ ...p, dealerCard: null }));
                                return updated;
                            });
                            const timeoutId2 = setTimeout(() => {
                                tiedPlayers.forEach((idx, i) => {
                                    const timeoutId3 = setTimeout(() => {
                                        const card = currentDeck.pop();
                                        setPlayers(prev => {
                                            const updated = [...prev];
                                            updated[idx] = { ...updated[idx], dealerCard: card };
                                            return updated;
                                        });
                                        if (i === tiedPlayers.length - 1) {
                                            const timeoutId4 = setTimeout(() => checkForDealerWinner(currentDeck), 1000);
                                            timeoutRefs.current.push(timeoutId4);
                                        }
                                    }, i * 500);
                                    timeoutRefs.current.push(timeoutId3);
                                });
                            }, 500);
                            timeoutRefs.current.push(timeoutId2);
                        }, 1500);
                        timeoutRefs.current.push(timeoutId1);
                    }
                    return currentPlayers;
                });
            };
            const startRound = (roundNum, currentPlayers, deckCount, dealerIdx) => {
                setIsRoundTransitioning(false);
                const cardsPerPlayer = roundNum + 2;
                setShowDealingAnimation(true);
                setDealingInfo({
                    dealerName: currentPlayers[dealerIdx].name,
                    dealerAvatar: currentPlayers[dealerIdx].avatar,
                    cardsPerPlayer: cardsPerPlayer,
                    roundNum: roundNum
                });
                const timeoutId = setTimeout(() => {
                    setShowingAIMelds(false);
                    setAiResultsToShow(null);
                    setShowingHumanFinalPlay(false);
                    setHumanFinalPlayResults(null);
                    setAllFinalPlaysComplete(false);
                    setRoundWinner(null);
                    setPlayersWhoHaveTakenFinalTurn(new Set());
                    let fullDeck = [];
                    for (let i = 0; i < deckCount; i++) {
                        fullDeck = fullDeck.concat(createDeck());
                    }
                    fullDeck = shuffle(fullDeck);
                    const updatedPlayers = currentPlayers.map(player => {
                        const hand = fullDeck.splice(0, cardsPerPlayer);
                        return {
                            ...player,
                            hand,
                            melds: [],
                            dealerCard: null,
                            playedOnCards: [],
                            dialogue: player.isAI ? getDialogue(player.character, 'start') : ""
                        };
                    });
                    const firstDiscard = fullDeck.pop();
                    const startingPlayerIndex = (dealerIdx + 1) % updatedPlayers.length;
                    setPlayers(updatedPlayers);
                    setDeck(fullDeck);
                    setDiscardPile([firstDiscard]);
                    setCurrentPlayerIndex(startingPlayerIndex);
                    setGamePhase('draw');
                    setWinnerMelds([]);
                    setBuildingPayMe(false);
                    setMeldBuildingComplete(false);
                    setPlayerMelds([]);
                    setCurrentMeld([]);
                    setMeldError('');
                    setShowDealingAnimation(false);
                    setMessage(`Round ${roundNum} - ${cardsPerPlayer} cards. ${updatedPlayers[dealerIdx].name} is dealer. Wild cards: ${getWildCardName(roundNum)} and Jokers`);
                }, 2000);
                timeoutRefs.current.push(timeoutId);
            };
            const getWildCardName = (roundNum) => {
                const cardNum = roundNum + 2;
                if (cardNum <= 10) return cardNum.toString();
                if (cardNum === 11) return 'Jacks';
                if (cardNum === 12) return 'Queens';
                return 'Kings';
            };
            const drawCard = (fromDiscard) => {
                if (gamePhase !== 'draw' && gamePhase !== 'finaldraw') return;
                let drawnCard;
                let newDeck = [...deck];
                let newDiscardPile = [...discardPile];
                if (fromDiscard && discardPile.length > 0) {
                    drawnCard = newDiscardPile.pop();
                } else {
                    if (newDeck.length === 0) {
                        if (newDiscardPile.length > 1) {
                            const topCard = newDiscardPile.pop();
                            newDeck = shuffle(newDiscardPile);
                            newDiscardPile = [topCard];
                            setMessage('Deck reshuffled from discard pile!');
                        } else if (newDiscardPile.length === 1) {
                            drawnCard = newDiscardPile.pop();
                            const updatedPlayers = [...players];
                            updatedPlayers[currentPlayerIndex].hand.push(drawnCard);
                            if (updatedPlayers[currentPlayerIndex].isAI) {
                                updatedPlayers[currentPlayerIndex].dialogue = getDialogue(updatedPlayers[currentPlayerIndex].character, 'draw');
                            }
                            setDeck(newDeck);
                            setDiscardPile(newDiscardPile);
                            setPlayers(updatedPlayers);
                            if (gamePhase === 'finaldraw') {
                                setGamePhase('finallaydown');
                                setMessage('Lay down your melds and add cards to visible melds. Click "Done with Melds" when ready to discard.');
                            } else {
                                setGamePhase('discard');
                                setMessage('Click a card to discard, or declare "Pay Me" if you have all valid melds');
                            }
                            return;
                        } else {
                            setMessage('No cards available to draw!');
                            return;
                        }
                    }
                    drawnCard = newDeck.pop();
                }
                const updatedPlayers = [...players];
                updatedPlayers[currentPlayerIndex].hand.push(drawnCard);
                if (updatedPlayers[currentPlayerIndex].isAI) {
                    updatedPlayers[currentPlayerIndex].dialogue = getDialogue(updatedPlayers[currentPlayerIndex].character, 'draw');
                }
                setDeck(newDeck);
                setDiscardPile(newDiscardPile);
                setPlayers(updatedPlayers);
                if (gamePhase === 'finaldraw') {
                    setGamePhase('finallaydown');
                    if (!updatedPlayers[currentPlayerIndex].isAI) {
                        setMessage('Lay down your melds and play cards on the winner\'s hand.');
                    }
                } else {
                    setGamePhase('discard');
                    if (!updatedPlayers[currentPlayerIndex].isAI) {
                        setMessage('Click a card to discard, or declare "Pay Me"');
                    }
                }
            };
            const animateCardDiscard = (cardElement, card, onComplete) => {
                if (!cardElement) {
                    onComplete();
                    return;
                }
                const cardRect = cardElement.getBoundingClientRect();
                const discardPile = document.querySelector('.discard-pile .card-stack');
                if (!discardPile) {
                    onComplete();
                    return;
                }
                const discardRect = discardPile.getBoundingClientRect();
                setFlyingCard({
                    card: card,
                    startX: cardRect.left,
                    startY: cardRect.top,
                    endX: discardRect.left,
                    endY: discardRect.top,
                    width: cardRect.width,
                    height: cardRect.height
                });
                const timeoutId = setTimeout(() => {
                    setFlyingCard(null);
                    onComplete();
                }, 600);
                timeoutRefs.current.push(timeoutId);
            };
            const handleDragStart = (e, index) => {
                setDraggedCardIndex(index);
                setDropTargetIndex(null);
                e.dataTransfer.effectAllowed = 'move';
                const rect = e.currentTarget.getBoundingClientRect();
                draggedCardRectRef.current = {
                    x: rect.left,
                    y: rect.top,
                    width: rect.width,
                    height: rect.height
                };
            };
            const handleTouchStart = (e, index) => {
                const touch = e.touches[0];
                setDraggedCardIndex(index);
                setDropTargetIndex(null);
                const rect = e.currentTarget.getBoundingClientRect();
                draggedCardRectRef.current = {
                    x: rect.left,
                    y: rect.top,
                    width: rect.width,
                    height: rect.height,
                    touchStartX: touch.clientX,
                    touchStartY: touch.clientY
                };
                e.currentTarget.style.opacity = '0.5';
            };
            const handleTouchMove = (e, index) => {
                if (draggedCardIndex === null) return;
                e.preventDefault();
                const touch = e.touches[0];
                const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
                const meldGroup = elements.find(el => el.classList && el.classList.contains('meld-group'));
                if (meldGroup && gamePhase === 'finallaydown' && !meldBuildingComplete) {
                    const allMeldGroups = document.querySelectorAll('.meld-group');
                    const meldIndex = Array.from(allMeldGroups).indexOf(meldGroup);
                    if (meldIndex !== -1) {
                        hoveredWinnerMeldRef.current = meldIndex;
                        setHoveredWinnerMeldIndex(meldIndex);
                        return;
                    }
                }
                const cardElement = elements.find(el => el.classList && el.classList.contains('card'));
                if (cardElement && cardElement !== e.currentTarget) {
                    const allCards = document.querySelectorAll('.hand-area .card');
                    const targetIndex = Array.from(allCards).indexOf(cardElement);
                    if (targetIndex !== -1 && targetIndex !== draggedCardIndex) {
                        const rect = cardElement.getBoundingClientRect();
                        const midPoint = rect.left + rect.width / 2;
                        if (touch.clientX < midPoint) {
                            setDropTargetIndex(targetIndex);
                        } else {
                            setDropTargetIndex(targetIndex + 1);
                        }
                    }
                }
            };
            const handleTouchEnd = (e, index) => {
                e.currentTarget.style.opacity = '1';
                if (draggedCardIndex === null) {
                    setDropTargetIndex(null);
                    return;
                }
                const touch = e.changedTouches[0];
                const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
                const winnerMeldCard = elements.find(el => el.classList && el.classList.contains('winner-hand-card'));
                if (winnerMeldCard && hoveredWinnerMeldRef.current !== null) {
                    const meldIndex = hoveredWinnerMeldRef.current;
                    handleDropOnWinnerMeld({preventDefault: () => {}, stopPropagation: () => {}}, meldIndex);
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    hoveredWinnerMeldRef.current = null;
                    return;
                }
                let targetIndex = dropTargetIndex !== null ? dropTargetIndex : index;
                if (draggedCardIndex === targetIndex || draggedCardIndex === targetIndex - 1) {
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                const updatedPlayers = [...players];
                const newHand = [...updatedPlayers[0].hand];
                const draggedCard = newHand[draggedCardIndex];
                newHand.splice(draggedCardIndex, 1);
                if (draggedCardIndex < targetIndex) {
                    targetIndex--;
                }
                newHand.splice(targetIndex, 0, draggedCard);
                updatedPlayers[0].hand = newHand;
                setPlayers(updatedPlayers);
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
            };
            const handleDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                if (draggedCardIndex !== null && draggedCardIndex !== index) {
                    const cardElement = e.currentTarget;
                    const rect = cardElement.getBoundingClientRect();
                    const midPoint = rect.left + rect.width / 2;
                    const mouseX = e.clientX;
                    if (mouseX < midPoint) {
                        setDropTargetIndex(index);
                    } else {
                        setDropTargetIndex(index + 1);
                    }
                }
            };
            const handleDragLeave = () => {
            };
            const handleDrop = (e, cardIndex) => {
                e.preventDefault();
                e.stopPropagation();
                if (draggedCardIndex === null) {
                    setDropTargetIndex(null);
                    return;
                }
                let targetIndex = dropTargetIndex !== null ? dropTargetIndex : cardIndex;
                if (draggedCardIndex === targetIndex || draggedCardIndex === targetIndex - 1) {
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                const updatedPlayers = [...players];
                const newHand = [...updatedPlayers[0].hand];
                const draggedCard = newHand[draggedCardIndex];
                newHand.splice(draggedCardIndex, 1);
                if (draggedCardIndex < targetIndex) {
                    targetIndex--;
                }
                newHand.splice(targetIndex, 0, draggedCard);
                updatedPlayers[0].hand = newHand;
                setPlayers(updatedPlayers);
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
            };
            const handleDragEnd = (e) => {
                if (hoveredWinnerMeldRef.current !== null && draggedCardIndex !== null) {
                    const meldIndex = hoveredWinnerMeldRef.current;
                    setCardBeingDroppedOnWinner(draggedCardIndex);
                    handleDropOnWinnerMeld({preventDefault: () => {}, stopPropagation: () => {}}, meldIndex);
                    setTimeout(() => {
                        setCardBeingDroppedOnWinner(null);
                    }, 100);
                    hoveredWinnerMeldRef.current = null;
                    setHoveredWinnerMeldIndex(null);
                    setDraggedCardIndex(null);
                    draggedCardRectRef.current = null;
                    return;
                }
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
                draggedCardRectRef.current = null;
            };
            const handleMeldDragStart = (e, index) => {
                setDraggedMeldCardIndex(index);
                e.dataTransfer.effectAllowed = 'move';
            };
            const handleMeldTouchStart = (e, index) => {
                setDraggedMeldCardIndex(index);
                e.currentTarget.style.opacity = '0.5';
            };
            const handleMeldTouchMove = (e, index) => {
                if (draggedMeldCardIndex === null) return;
                e.preventDefault();
                const touch = e.touches[0];
                const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
                const cardElement = elements.find(el => el.classList && el.classList.contains('card'));
                if (cardElement && cardElement !== e.currentTarget) {
                    const allMeldCards = document.querySelectorAll('.current-meld-preview .card');
                    const targetIndex = Array.from(allMeldCards).indexOf(cardElement);
                    if (targetIndex !== -1 && targetIndex !== draggedMeldCardIndex) {
                        const rect = cardElement.getBoundingClientRect();
                        const midPoint = rect.left + rect.width / 2;
                        if (touch.clientX < midPoint) {
                            setDropTargetMeldIndex(targetIndex);
                        } else {
                            setDropTargetMeldIndex(targetIndex + 1);
                        }
                    }
                }
            };
            const handleMeldTouchEnd = (e, cardIndex) => {
                e.currentTarget.style.opacity = '1';
                if (draggedMeldCardIndex === null) {
                    setDropTargetMeldIndex(null);
                    return;
                }
                let insertIndex = dropTargetMeldIndex !== null ? dropTargetMeldIndex : cardIndex;
                if (draggedMeldCardIndex < insertIndex) {
                    insertIndex--;
                }
                if (draggedMeldCardIndex === insertIndex) {
                    setDraggedMeldCardIndex(null);
                    setDropTargetMeldIndex(null);
                    return;
                }
                const newMeld = [...currentMeld];
                const [draggedCard] = newMeld.splice(draggedMeldCardIndex, 1);
                newMeld.splice(insertIndex, 0, draggedCard);
                setCurrentMeld(newMeld);
                setDraggedMeldCardIndex(null);
                setDropTargetMeldIndex(null);
                setMessage(`Moved ${draggedCard.rank}${draggedCard.suit} from position ${draggedMeldCardIndex + 1} to ${insertIndex + 1}`);
            };
            const handleMeldDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                if (draggedMeldCardIndex === null || draggedMeldCardIndex === index) {
                    return;
                }
                const cardElement = e.currentTarget;
                const rect = cardElement.getBoundingClientRect();
                const mouseX = e.clientX;
                const midPoint = rect.left + rect.width / 2;
                if (mouseX < midPoint) {
                    setDropTargetMeldIndex(index);
                } else {
                    setDropTargetMeldIndex(index + 1);
                }
            };
            const handleMeldDrop = (e, cardIndex) => {
                e.preventDefault();
                if (draggedMeldCardIndex === null) {
                    setDropTargetMeldIndex(null);
                    return;
                }
                let insertIndex = dropTargetMeldIndex !== null ? dropTargetMeldIndex : cardIndex;
                if (draggedMeldCardIndex < insertIndex) {
                    insertIndex--;
                }
                if (draggedMeldCardIndex === insertIndex) {
                    setDraggedMeldCardIndex(null);
                    setDropTargetMeldIndex(null);
                    return;
                }
                const newMeld = [...currentMeld];
                const [draggedCard] = newMeld.splice(draggedMeldCardIndex, 1);
                newMeld.splice(insertIndex, 0, draggedCard);
                setCurrentMeld(newMeld);
                setDraggedMeldCardIndex(null);
                setDropTargetMeldIndex(null);
                setMessage(`Moved ${draggedCard.rank}${draggedCard.suit} from position ${draggedMeldCardIndex + 1} to ${insertIndex + 1}`);
            };
            const handleMeldDragEnd = () => {
                setDraggedMeldCardIndex(null);
                setDropTargetMeldIndex(null);
            };
            const handleDropOnWinnerMeld = (e, meldIndex, playerIndexOverride = 0, cardIndexOverride = null, removeFromHand = false) => {
                if (e.preventDefault) e.preventDefault();
                if (e.stopPropagation) e.stopPropagation();
                const cardIndex = (cardIndexOverride !== null && cardIndexOverride !== undefined) ? cardIndexOverride : draggedCardIndex;
                const playerIndex = playerIndexOverride;
                if (cardIndex === null) {
                    return;
                }
                if (roundWinner === null) {
                    return;
                }
                if (gamePhase !== 'finallaydown' || meldBuildingComplete) {
                    return;
                }
                const card = players[playerIndex].hand[cardIndex];
                const meld = players[roundWinner].melds[meldIndex];
                if (!isWild(card, round)) {
                    const cardRankSuit = `${card.rank}${card.suit}`;
                    const wildRepresentsThisCard = meld.some(c =>
                        c.representsCard === cardRankSuit
                    );
                    if (wildRepresentsThisCard) {
                        const nonWilds = meld.filter(c => !isWild(c, round));
                        const isLikelyRun = nonWilds.length > 0 && nonWilds.every(c => c.suit === card.suit);
                        if (isLikelyRun) {
                            setMessage(`Can't add ${card.rank}${card.suit} - a wild card already represents it!`);
                            setDraggedCardIndex(null);
                            setDropTargetIndex(null);
                            return;
                        }
                    }
                }
                const meldWithWilds = meld.map(c => ({
                    ...c,
                    isWildForRound: isWild(c, round),
                    ...(c.representsCard && { representsCard: c.representsCard })
                }));
                const hasLockedRepresentations = meldWithWilds.some(c => c && c.representsCard);
                let meldIsSet = false;
                let meldIsRun = false;
                if (hasLockedRepresentations) {
                    meldIsRun = isValidRun(meldWithWilds, round);
                    meldIsSet = !meldIsRun && isValidSet(meldWithWilds, round);
                } else {
                    meldIsSet = isValidSet(meldWithWilds, round);
                    meldIsRun = !meldIsSet && isValidRun(meldWithWilds, round);
                }
                if (!meldIsSet && !meldIsRun) {
                    setMessage(`Can't add to this meld - it's invalid`);
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                const testMeld = [
                    ...meld.map(c => ({
                        ...c,
                        isWildForRound: isWild(c, round),
                        ...(c.representsCard && { representsCard: c.representsCard })
                    })),
                    { ...card, isWildForRound: isWild(card, round) }
                ];
                let validAfterAdd = false;
                if (meldIsSet) {
                    validAfterAdd = isValidSet(testMeld, round);
                } else if (meldIsRun) {
                                    if (!canExtendRunOnEnd(meldWithWilds, card, round)) {
                                        setMessage(`Can only extend runs on the ends`);
                                        setDraggedCardIndex(null);
                                        setDropTargetIndex(null);
                                        return;
                                    }
                                    validAfterAdd = isValidRun(testMeld, round);
                }
                if (!validAfterAdd) {
                    const meldType = meldIsSet ? 'set' : 'run';
                    setMessage(`Can't add ${card.rank}${card.suit} to this ${meldType} - it would be invalid`);
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                const updatedPlayers = [...players];
                const updatedMeld = [
                    ...meld,
                    { ...card, isWildForRound: isWild(card, round), addedBy: updatedPlayers[playerIndex].avatar }
                ];
                let finalMeld;
                if (meldIsRun && isWild(card, round)) {
                    const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    const nonWildCards = meld.filter(c => !isWild(c, round) && !c.representsCard);
                    const suit = nonWildCards.length > 0 ? nonWildCards[0].suit :
                                 (meld.find(c => c.representsCard) ? meld.find(c => c.representsCard).representsCard.slice(-1) : 'â™ ');
                    const currentRanks = meld.map(c => {
                        if (c.representsCard) {
                            return c.representsCard.slice(0, -1);
                        }
                        return c.rank;
                    });
                    const currentIndices = currentRanks.map(r => rankOrder.indexOf(r)).sort((a, b) => a - b);
                    const hasAce = currentIndices.includes(0);
                    const hasHighCards = currentIndices.some(idx => idx >= 10);
                    let adjustedIndices = [...currentIndices];
                    if (hasAce && hasHighCards) {
                        const minNonAce = Math.min(...currentIndices.filter(i => i !== 0));
                        if (minNonAce >= 9) {
                            adjustedIndices = currentIndices.map(i => i === 0 ? 13 : i);
                        }
                    }
                    const min = Math.min(...adjustedIndices);
                    const max = Math.max(...adjustedIndices);
                    const options = [];
                    if (min > 0) {
                        const belowRank = min === 13 ? 'K' : rankOrder[min - 1];
                        options.push({ rank: belowRank, display: `${belowRank}${suit}` });
                    }
                    if (max < 12) {
                        const aboveRank = rankOrder[max + 1];
                        options.push({ rank: aboveRank, display: `${aboveRank}${suit}` });
                    } else if (max === 12 && !adjustedIndices.includes(13) && !adjustedIndices.includes(0)) {
                        options.push({ rank: 'A', display: `A${suit}` });
                    }
                    if (options.length === 1) {
                        const chosenRank = options[0].rank;
                        finalMeld = [...updatedMeld];
                        finalMeld[finalMeld.length - 1] = {
                            ...finalMeld[finalMeld.length - 1],
                            representsCard: `${chosenRank}${suit}`
                        };
                    } else if (options.length > 1) {
                        setWinnerMeldWildPicker({
                            card: card,
                            meldIndex: meldIndex,
                            cardIndex: cardIndex,
                            playerIndex: playerIndex,
                            options: options.map(o => ({ rank: o.rank, suit: suit, display: o.display })),
                            updatedMeld: updatedMeld,
                            updatedPlayers: updatedPlayers
                        });
                        setDraggedCardIndex(null);
                        setDropTargetIndex(null);
                        return;
                    } else {
                        setDraggedCardIndex(null);
                        setDropTargetIndex(null);
                        setMessage('Cannot place wild card in this run.');
                        return;
                    }
                } else if (meldIsSet) {
                    const nonWilds = updatedMeld.filter(c => !isWild(c, round));
                    const setRank = nonWilds.length > 0 ? nonWilds[0].rank : null;
                    finalMeld = updatedMeld.map(c => {
                        if (isWild(c, round) && setRank) {
                            return { ...c, representsCard: `${setRank}${c.suit}` };
                        }
                        return {...c};
                    });
                } else {
                    finalMeld = updatedMeld;
                }
                const sortedMeld = sortMeld(finalMeld, round);
                updatedPlayers[roundWinner].melds[meldIndex] = sortedMeld;
                if (!updatedPlayers[playerIndex].playedOnCards) {
                    updatedPlayers[playerIndex].playedOnCards = [];
                }
                updatedPlayers[playerIndex].playedOnCards.push({
                    ...card,
                    playedOn: `${players[roundWinner].name}'s meld ${meldIndex + 1}`,
                    addedBy: updatedPlayers[playerIndex].avatar
                });
                if (removeFromHand) {
                    updatedPlayers[playerIndex].hand = updatedPlayers[playerIndex].hand.filter((_, i) => i !== cardIndex);
                }
                setPlayers(updatedPlayers);
                setMessage(`Added ${card.rank}${card.suit} to ${players[roundWinner].name}'s meld!`);
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
            };
            const handleDragFromSavedMeld = (e, meldIndex, cardIndex) => {
                e.dataTransfer.setData('meldIndex', meldIndex);
                e.dataTransfer.setData('cardIndex', cardIndex);
                e.dataTransfer.effectAllowed = 'move';
            };
            const handleDropBackToHand = (e) => {
                e.preventDefault();
                const winnerMeldIndex = e.dataTransfer.getData('winnerMeldIndex');
                const winnerMeldCardIndex = e.dataTransfer.getData('winnerMeldCardIndex');
                if (winnerMeldIndex !== '' && winnerMeldCardIndex !== '') {
                    const meldIdx = parseInt(winnerMeldIndex);
                    const cardIdx = parseInt(winnerMeldCardIndex);
                    const updatedPlayers = [...players];
                    const winnerMeld = updatedPlayers[roundWinner].melds[meldIdx];
                    const card = winnerMeld[cardIdx];
                    if (!card.addedBy) {
                        setMessage("You can only remove cards that you added!");
                        return;
                    }
                    const updatedMeld = winnerMeld.filter((_, idx) => idx !== cardIdx);
                    updatedPlayers[roundWinner].melds[meldIdx] = updatedMeld;
                    const cleanCard = {
                        rank: card.rank,
                        suit: card.suit,
                        id: card.id,
                        isRed: card.isRed,
                        isWildForRound: card.isWildForRound
                    };
                    if (card.representsCard && card.isWildForRound) {
                        cleanCard.representsCard = card.representsCard;
                    }
                    if (!updatedPlayers[0].hand.some(c => c.id === cleanCard.id)) {
                        updatedPlayers[0].hand.push(cleanCard);
                    }
                    if (updatedPlayers[0].playedOnCards) {
                        updatedPlayers[0].playedOnCards = updatedPlayers[0].playedOnCards.filter(c => c.id !== card.id);
                    }
                    setPlayers(updatedPlayers);
                    setMessage(`Removed ${card.rank}${card.suit} from ${players[roundWinner].name}'s meld`);
                    return;
                }
                if (draggedMeldCardIndex !== null) {
                    const newMeld = currentMeld.filter((_, idx) => idx !== draggedMeldCardIndex);
                    setCurrentMeld(newMeld);
                    setDraggedMeldCardIndex(null);
                    setDropTargetMeldIndex(null);
                    setMessage('Card removed from current meld');
                    return;
                }
                const meldIndex = e.dataTransfer.getData('meldIndex');
                const cardIndex = e.dataTransfer.getData('cardIndex');
                if (meldIndex === '' || cardIndex === '') return;
                const meldIdx = parseInt(meldIndex);
                const cardIdx = parseInt(cardIndex);
                const meld = playerMelds[meldIdx];
                const card = meld[cardIdx];
                const updatedPlayers = [...players];
                if (!updatedPlayers[0].hand.some(c => c.id === card.id)) {
                    updatedPlayers[0].hand.push(card);
                }
                const updatedMelds = [...playerMelds];
                updatedMelds[meldIdx] = meld.filter((_, idx) => idx !== cardIdx);
                if (updatedMelds[meldIdx].length < 3) {
                    updatedMelds[meldIdx].forEach(c => {
                        if (!updatedPlayers[0].hand.some(h => h.id === c.id)) {
                            updatedPlayers[0].hand.push(c);
                        }
                    });
                    updatedMelds.splice(meldIdx, 1);
                }
                setPlayers(updatedPlayers);
                setPlayerMelds(updatedMelds);
                setMessage('Card returned to hand');
                setDraggedCardIndex(null);
            };
            const openScoreboard = () => {
                setShowingHumanFinalPlay(false);
                setHumanFinalPlayResults(null);
                setShowingAIMelds(false);
                setAiResultsToShow(null);
                setAllFinalPlaysComplete(true);
                nextFinalTurnActionRef.current = null;
            };
            const closeScoreboard = () => {
                setAllFinalPlaysComplete(false);
                setPlayersWhoHaveTakenFinalTurn(new Set());
                setRoundWinner(null);
            };
            const validatePlayerCanEndTurn = (player, currentHand) => {
                if (!currentHand || currentHand.length === 0) {
                    alert('Error: You must have at least one card to discard before ending your turn.');
                    return false;
                }
                return true;
            };
            const discardCard = (cardIndex) => {
                if (isDiscardingRef.current) {
                    return;
                }
                if (gamePhase !== 'discard' && gamePhase !== 'finaldiscard') {
                    return;
                }
                isDiscardingRef.current = true;
                setIsDiscarding(true);
                const wasFinaldiscard = gamePhase === 'finaldiscard';
                setGamePhase(wasFinaldiscard ? 'finaldiscard_processing' : 'discard_processing');
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[currentPlayerIndex];
                const discardedCard = currentPlayer.hand.splice(cardIndex, 1)[0];
                const newDiscardPile = [...discardPile, discardedCard];
                const discardMessage = currentPlayer.isAI
                    ? `${currentPlayer.name} discarded ${discardedCard.rank}${discardedCard.suit}`
                    : `You discarded ${discardedCard.rank}${discardedCard.suit}`;
                setMessage(discardMessage);
                if (currentPlayer.isAI) {
                    currentPlayer.dialogue = getDialogue(currentPlayer.character, 'discard');
                }
                setPlayers(updatedPlayers);
                setDiscardPile(newDiscardPile);
                setSelectedCard(null);
                if (wasFinaldiscard) {
                    setPlayersWhoHaveTakenFinalTurn(prev => new Set([...prev, currentPlayerIndex]));
                    if (currentPlayer.isAI) {
                        const points = calculateScore(currentPlayer.hand);
                        setAiResultsToShow({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [...currentPlayer.hand],
                            discard: discardedCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        setShowingAIMelds(true);
                        setMeldError('');
                        setIsDiscarding(false);
                        isDiscardingRef.current = false;
                        const nextIndex = (currentPlayerIndex + 1) % players.length;
                        if (nextIndex === roundWinner) {
                            nextFinalTurnActionRef.current = () => {
                                setShowingAIMelds(false);
                                setAiResultsToShow(null);
                                setHumanFinalPlayResults(null);
                                setAllFinalPlaysComplete(true);
                            };
                        } else {
                            const isNextHuman = !players[nextIndex].isAI;
                            nextFinalTurnActionRef.current = () => {
                                setCurrentPlayerIndex(nextIndex);
                                setGamePhase('finaldraw');
                                if (isNextHuman) {
                                    setMessage('Your final turn - draw a card');
                                } else {
                                    setMessage(`${players[nextIndex].name}'s final turn...`);
                                }
                            };
                        }
                        return;
                    }
                    const nextIndex = (currentPlayerIndex + 1) % players.length;
                    if (nextIndex === roundWinner) {
                        const points = calculateScore(currentPlayer.hand);
                        setHumanFinalPlayResults({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [...currentPlayer.hand],
                            discard: discardedCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        setShowingHumanFinalPlay(true);
                        setIsDiscarding(false);
                        isDiscardingRef.current = false;
                        nextFinalTurnActionRef.current = () => {
                            setShowingHumanFinalPlay(false);
                            setHumanFinalPlayResults(null);
                            setAllFinalPlaysComplete(true);
                        };
                    } else {
                        const points = calculateScore(currentPlayer.hand);
                        setHumanFinalPlayResults({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [...currentPlayer.hand],
                            discard: discardedCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        setShowingHumanFinalPlay(false);
                        const isNextHuman = !players[nextIndex].isAI;
                        const timeoutId = setTimeout(() => {
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                            setIsDiscarding(false);
                            isDiscardingRef.current = false;
                            if (isNextHuman) {
                                setMessage('Your final turn - draw a card');
                            } else {
                                setMessage(`${players[nextIndex].name}'s final turn...`);
                            }
                        }, 1000);
                        timeoutRefs.current.push(timeoutId);
                    }
                    return;
                }
                if (currentPlayer.isAI) {
                    const timeoutId = setTimeout(() => {
                        nextTurn();
                        setIsDiscarding(false);
                        isDiscardingRef.current = false;
                    }, 1200 / aiSpeed);
                    timeoutRefs.current.push(timeoutId);
                } else {
                    nextTurn();
                    setIsDiscarding(false);
                    isDiscardingRef.current = false;
                }
            };
            const startPayMeDeclaration = () => {
                setBuildingPayMe(true);
                setPlayerMelds([]);
                setCurrentMeld([]);
                setMeldError('');
                setGamePhase('paymebuilding');
                const requiredCards = round + 2;
                setMessage(`Build your melds. You must use exactly ${requiredCards} cards in valid melds. The remaining card will be automatically discarded.`);
            };
            const cancelPayMeDeclaration = () => {
                setBuildingPayMe(false);
                setPlayerMelds([]);
                setCurrentMeld([]);
                setMeldError('');
                setGamePhase('discard');
                setMessage('Click a card to discard');
            };
            const assignWildCard = (meldCardIndex) => {
                const card = currentMeld[meldCardIndex];
                if (!isWild(card, round)) return;
                setWildCardToAssign(meldCardIndex);
            };
            const getPossibleWildValues = () => {
                if (wildCardToAssign === null || currentMeld.length < 2) return [];
                const nonWilds = currentMeld.filter(c => !isWild(c, round));
                if (nonWilds.length === 0) return [];
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                const possibleValues = [];
                const firstNonWildRank = nonWilds[0].rank;
                const isLikelySet = nonWilds.every(c => c.rank === firstNonWildRank);
                const firstNonWildSuit = nonWilds[0].suit;
                const isLikelySameSuit = nonWilds.every(c => c.suit === firstNonWildSuit);
                if (isLikelySet && nonWilds.length >= 1) {
                    const usedSuits = new Set(nonWilds.map(c => c.suit));
                    currentMeld.forEach(c => {
                        if (isWild(c, round) && c.representsCard) {
                            const match = c.representsCard.match(/([â™¥â™¦â™£â™ ])$/);
                            if (match) usedSuits.add(match[1]);
                        }
                    });
                    SUITS.forEach(suit => {
                        if (!usedSuits.has(suit)) {
                            possibleValues.push({ rank: firstNonWildRank, suit, display: `${firstNonWildRank}${suit}` });
                        }
                    });
                }
                if (isLikelySameSuit && nonWilds.length >= 1) {
                    const suit = firstNonWildSuit;
                    const nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
                    const assignedRanks = new Set(nonWildRanks);
                    currentMeld.forEach(c => {
                        if (isWild(c, round) && c.representsCard) {
                            const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                            if (match) {
                                assignedRanks.add(rankOrder.indexOf(match[1]));
                            }
                        }
                    });
                    const minRank = Math.min(...assignedRanks);
                    const maxRank = Math.max(...assignedRanks);
                    for (let r = minRank; r <= maxRank; r++) {
                        if (!assignedRanks.has(r)) {
                            possibleValues.push({ rank: rankOrder[r], suit, display: `${rankOrder[r]}${suit}` });
                        }
                    }
                    if (minRank > 0) {
                        possibleValues.push({ rank: rankOrder[minRank - 1], suit, display: `${rankOrder[minRank - 1]}${suit}` });
                    }
                    if (maxRank < 12) {
                        possibleValues.push({ rank: rankOrder[maxRank + 1], suit, display: `${rankOrder[maxRank + 1]}${suit}` });
                    }
                    if (maxRank === 12 && !assignedRanks.has(0)) {
                        possibleValues.push({ rank: 'A', suit, display: `A${suit}`, isAceHigh: true });
                    }
                }
                const seen = new Set();
                return possibleValues.filter(v => {
                    const key = v.display;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            };
            const selectWildValue = (rank, suit) => {
                if (wildCardToAssign === null) return;
                const card = currentMeld[wildCardToAssign];
                const representsCard = `${rank}${suit}`;
                const updated = [...currentMeld];
                updated[wildCardToAssign] = { ...card, representsCard };
                setCurrentMeld(updated);
                setWildCardToAssign(null);
                setMessage(`${card.rank}${card.suit} now represents ${representsCard}`);
                const callback = wildAssignmentCallback;
                const timeoutId = setTimeout(() => {
                    const markedCards = updated.map(c => ({...c, isWildForRound: isWild(c, round)}));
                    const unassignedWilds = markedCards.filter(c => c.isWildForRound && !c.representsCard);
                    if (unassignedWilds.length === 0) {
                        setWildAssignmentCallback(null);
                        if (callback) {
                            callback();
                        }
                        return;
                    }
                    if (isValidRun(updated, round)) {
                        const nonWilds = markedCards.filter(c => !c.isWildForRound || c.representsCard);
                        if (nonWilds.length > 0) {
                            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                            let nonWildRanks = nonWilds.map(c => {
                                if (c.representsCard) {
                                    const repRank = c.representsCard.slice(0, -1);
                                    return rankOrder.indexOf(repRank);
                                }
                                return rankOrder.indexOf(c.rank);
                            }).sort((a, b) => a - b);
                            const hasAce = nonWildRanks.includes(0);
                            const hasHighCards = nonWildRanks.some(r => r >= 10);
                            const canExtendLow = nonWildRanks[0] > 0;
                            const canExtendHigh = nonWildRanks[nonWildRanks.length - 1] < 12;
                            const canExtendHighWithAce = hasHighCards && nonWildRanks[nonWildRanks.length - 1] === 12;
                            let validPositions = 0;
                            if (canExtendLow) validPositions++;
                            if (canExtendHigh) validPositions++;
                            if (canExtendHighWithAce) validPositions++;
                            if (validPositions > 1 || (hasAce && hasHighCards && unassignedWilds.length > 0)) {
                                const firstUnassignedIdx = updated.findIndex(c => isWild(c, round) && !c.representsCard);
                                if (firstUnassignedIdx >= 0) {
                                    setWildCardToAssign(firstUnassignedIdx);
                                }
                                return;
                            }
                        }
                    }
                    setWildAssignmentCallback(null);
                    if (callback) {
                        callback();
                    }
                }, 100);
                timeoutRefs.current.push(timeoutId);
            };
            const cancelWildAssignment = () => {
                setWildCardToAssign(null);
            };
            const selectWinnerMeldWildValue = (rank, suit) => {
                if (!winnerMeldWildPicker) return;
                const { card, meldIndex, updatedMeld, updatedPlayers, playerIndex } = winnerMeldWildPicker;
                const finalMeld = [...updatedMeld];
                finalMeld[finalMeld.length - 1] = {
                    ...finalMeld[finalMeld.length - 1],
                    representsCard: `${rank}${suit}`
                };
                const sortedMeld = sortMeld(finalMeld, round);
                updatedPlayers[roundWinner].melds[meldIndex] = sortedMeld;
                if (!updatedPlayers[playerIndex].playedOnCards) {
                    updatedPlayers[playerIndex].playedOnCards = [];
                }
                updatedPlayers[playerIndex].playedOnCards.push({
                    ...card,
                    playedOn: `${players[roundWinner].name}'s meld ${meldIndex + 1}`,
                    addedBy: updatedPlayers[playerIndex].avatar
                });
                setPlayers(updatedPlayers);
                setMessage(`Added ${card.rank}${card.suit} (as ${rank}${suit}) to ${players[roundWinner].name}'s meld!`);
                setWinnerMeldWildPicker(null);
            };
            const cancelWinnerMeldWildPicker = () => {
                setWinnerMeldWildPicker(null);
            };
            const toggleCardInMeld = (cardIndex) => {
                if (!players || !players[0] || !players[0].hand) {
                    console.error('Players not initialized');
                    return;
                }
                const card = players[0].hand[cardIndex];
                if (!card) {
                    console.error('Card not found at index', cardIndex);
                    return;
                }
                const cardInCurrentMeld = currentMeld.some(c => c.index === cardIndex);
                const cardInAnyMeld = playerMelds.some(meld => meld.some(c => c.index === cardIndex));
                if (cardInCurrentMeld) {
                    setCurrentMeld(currentMeld.filter(c => c.index !== cardIndex));
                } else if (!cardInAnyMeld) {
                    setCurrentMeld([...currentMeld, { ...card, index: cardIndex, isWildForRound: isWild(card, round) }]);
                }
                setMeldError('');
            };
            const saveCurrentMeld = () => {
                if (currentMeld.length < 3) {
                    setMeldError('A meld must have at least 3 cards');
                    return;
                }
                const { canBeSet, canBeRun } = getMeldType(currentMeld, round);
                if (!canBeSet && !canBeRun) {
                    setMeldError('Invalid meld! Must be a valid set (same rank) or run (consecutive cards of same suit)');
                    return;
                }
                const markedCards = currentMeld.map(c => ({...c, isWildForRound: isWild(c, round)}));
                const unassignedWilds = markedCards.filter(c => c.isWildForRound && !c.representsCard);
                if (unassignedWilds.length > 0 || (canBeSet && canBeRun)) {
                    const interpretations = getPossibleMeldInterpretations(currentMeld, round);
                    if (interpretations.allWilds) {
                        setMeldPickerAllWilds(true);
                        setMeldPickerStep(1);
                        setShowMeldPicker(true);
                        setMeldError('');
                        return;
                    }
                    if (interpretations.options.length === 0) {
                        setMeldError('Cannot determine valid meld interpretation');
                        return;
                    }
                    const hasWilds = unassignedWilds.length > 0;
                    const isBothSetAndRun = canBeSet && canBeRun;
                    if (interpretations.options.length === 1 && !hasWilds) {
                        const option = interpretations.options[0];
                        let meldToSave = [...currentMeld];
                        meldToSave = meldToSave.map(card => {
                            if (isWild(card, round) && option.assignments[card.id]) {
                                return { ...card, representsCard: option.assignments[card.id] };
                            }
                            return card;
                        });
                        const sortedMeld = sortMeld(meldToSave, round);
                        setPlayerMelds([...playerMelds, sortedMeld]);
                        setCurrentMeld([]);
                        setMeldError('');
                    } else if (interpretations.options.length === 1 && hasWilds && !isBothSetAndRun) {
                        const option = interpretations.options[0];
                        let meldToSave = [...currentMeld];
                        meldToSave = meldToSave.map(card => {
                            if (isWild(card, round) && option.assignments[card.id]) {
                                return { ...card, representsCard: option.assignments[card.id] };
                            }
                            return card;
                        });
                        const sortedMeld = sortMeld(meldToSave, round);
                        setPlayerMelds([...playerMelds, sortedMeld]);
                        setCurrentMeld([]);
                        setMeldError('');
                    } else {
                        setMeldPickerOptions(interpretations.options);
                        setMeldPickerAllWilds(false);
                        setShowMeldPicker(true);
                        setMeldError('');
                    }
                    return;
                }
                let meldToSave = [...currentMeld];
                if (canBeSet) {
                    meldToSave = assignWildsInSet(meldToSave, round);
                } else if (canBeRun) {
                    meldToSave = assignJokersInRun(meldToSave, round);
                }
                const sortedMeld = sortMeld(meldToSave, round);
                setPlayerMelds([...playerMelds, sortedMeld]);
                setCurrentMeld([]);
                setMeldError('');
            };
            const handleMeldPickerSelection = (option) => {
                console.log('Meld picker selection:', option);
                let meldToSave = [...currentMeld];
                if (option.type === 'set') {
                    meldToSave = assignWildsInSet(meldToSave, round);
                } else {
                    meldToSave = meldToSave.map(card => {
                        if (isWild(card, round) && option.assignments[card.id]) {
                            return { ...card, representsCard: option.assignments[card.id] };
                        }
                        return card;
                    });
                    const stillUnassigned = meldToSave.filter(c => isWild(c, round) && !c.representsCard);
                    if (stillUnassigned.length > 0) {
                        const newInterpretations = getPossibleMeldInterpretations(meldToSave, round);
                        if (newInterpretations.options.length === 1) {
                            const autoOption = newInterpretations.options[0];
                            meldToSave = meldToSave.map(card => {
                                if (isWild(card, round) && autoOption.assignments[card.id]) {
                                    return { ...card, representsCard: autoOption.assignments[card.id] };
                                }
                                return card;
                            });
                        }
                    }
                }
                const sortedMeld = sortMeld(meldToSave, round);
                setShowMeldPicker(false);
                setMeldPickerOptions([]);
                setMeldPickerAllWilds(false);
                setMeldPickerStep(1);
                setMeldPickerSelectedType(null);
                setMeldPickerSelectedSuit(null);
                setTimeout(() => {
                    setPlayerMelds([...playerMelds, sortedMeld]);
                    setCurrentMeld([]);
                    setMeldError('');
                    if (pendingFinalizeAfterPick) {
                        setPendingFinalizeAfterPick(false);
                        setTimeout(() => {
                            finalizeFinalMelds();
                        }, 0);
                    }
                }, 0);
            };
            const handleMeldPickerCancel = () => {
                setShowMeldPicker(false);
                setMeldPickerOptions([]);
                setMeldPickerAllWilds(false);
                setMeldPickerStep(1);
                setMeldPickerSelectedType(null);
                setMeldPickerSelectedSuit(null);
                setPendingFinalizeAfterPick(false);
            };
            const handleAllWildsMeldTypeSelection = (type) => {
                setMeldPickerSelectedType(type);
                setMeldPickerStep(2);
            };
            const handleAllWildsSuitOrRankSelection = (value) => {
                if (meldPickerSelectedType === 'set') {
                    const assignments = {};
                    const usedSuits = new Set();
                    currentMeld.forEach((card, idx) => {
                        let suit;
                        if (idx < SUITS.length) {
                            suit = SUITS[idx];
                        } else {
                            suit = SUITS[Math.floor(Math.random() * SUITS.length)];
                        }
                        assignments[card.id] = `${value}${suit}`;
                        usedSuits.add(suit);
                    });
                    let meldToSave = currentMeld.map(card => ({
                        ...card,
                        representsCard: assignments[card.id]
                    }));
                    const sortedMeld = sortMeld(meldToSave, round);
                    setPlayerMelds([...playerMelds, sortedMeld]);
                    setCurrentMeld([]);
                    setMeldError('');
                    const shouldContinueFinalize = pendingFinalizeAfterPick;
                    handleMeldPickerCancel();
                    if (shouldContinueFinalize) {
                        setTimeout(() => finalizeFinalMelds(), 0);
                    }
                } else {
                    setMeldPickerSelectedSuit(value);
                    setMeldPickerStep(3);
                }
            };
            const handleAllWildsRunSelection = (startRank) => {
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                const startIdx = rankOrder.indexOf(startRank);
                const assignments = {};
                if (startIdx === -1) return;
                currentMeld.forEach((card, idx) => {
                    const rankIdx = startIdx + idx;
                    if (rankIdx >= 0 && rankIdx < rankOrder.length) {
                        const rank = rankOrder[rankIdx];
                        assignments[card.id] = `${rank}${meldPickerSelectedSuit}`;
                    }
                });
                let meldToSave = currentMeld.map(card => ({
                    ...card,
                    representsCard: assignments[card.id]
                }));
                const sortedMeld = sortMeld(meldToSave, round);
                setPlayerMelds([...playerMelds, sortedMeld]);
                setCurrentMeld([]);
                setMeldError('');
                const shouldContinueFinalize = pendingFinalizeAfterPick;
                handleMeldPickerCancel();
                if (shouldContinueFinalize) {
                    setTimeout(() => finalizeFinalMelds(), 0);
                }
            };
            const removeMeld = (meldIndex) => {
                setPlayerMelds(playerMelds.filter((_, idx) => idx !== meldIndex));
            };
            const finalizePayMe = () => {
                if (currentMeld.length >= 3) {
                    const interpretations = getPossibleMeldInterpretations(currentMeld, round);
                    if (interpretations.allWilds) {
                        setMeldPickerAllWilds(true);
                        setMeldPickerStep(1);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    if (interpretations.options && interpretations.options.length > 1) {
                        setMeldPickerOptions(interpretations.options);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    if (currentMeld.length < 3) {
                        setMeldError('Current meld must have at least 3 cards. Please finish it or remove cards to continue.');
                        return;
                    }
                    const isSet = isValidSet(currentMeld, round);
                    const isRun = isValidRun(currentMeld, round);
                    if (!isSet && !isRun) {
                        setMeldError('Current meld is not a valid set or run. Please fix it or remove cards to continue.');
                        return;
                    }
                    playerMelds.push([...currentMeld]);
                    setCurrentMeld([]);
                }
                const requiredCards = round + 2;
                const cardsInMelds = new Set();
                playerMelds.forEach(meld => {
                    meld.forEach(card => cardsInMelds.add(card.index));
                });
                if (cardsInMelds.size !== requiredCards) {
                    setMeldError(`You must use exactly ${requiredCards} cards in valid melds. Currently ${cardsInMelds.size} cards are in melds.`);
                    return;
                }
                const remainingCardIndex = players[0].hand.findIndex((card, idx) => !cardsInMelds.has(idx));
                if (remainingCardIndex === -1) {
                    setMeldError('Error: No card to discard. You should have exactly one card left.');
                    return;
                }
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[0];
                const discardedCard = currentPlayer.hand.splice(remainingCardIndex, 1)[0];
                const newDiscardPile = [...discardPile, discardedCard];
                const updatedMelds = playerMelds.map(meld =>
                    meld.filter(c => c.index !== remainingCardIndex).map(c => {
                        const {index, ...cardWithoutIndex} = c;
                        return cardWithoutIndex;
                    })
                ).filter(meld => meld.length >= 3);
                const meldsWithJokers = updatedMelds.map(meld => {
                    const hasWilds = meld.some(card => isWild(card, round));
                    if (hasWilds) {
                        if (isValidRun(meld, round)) {
                            const meldWithAssignedWilds = assignJokersInRun(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        } else if (isValidSet(meld, round)) {
                            const meldWithAssignedWilds = assignWildsInSet(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        }
                    }
                    return sortMeld(meld, round);
                });
                updatedPlayers[0].melds = meldsWithJokers;
                updatedPlayers[0].hand = [];
                const finalPlayers = updatedPlayers.map((p, idx) => {
                    if (idx === 0) {
                        return { ...p, quarters: p.quarters + players.length - 1 };
                    } else {
                        return { ...p, quarters: p.quarters - 1 };
                    }
                });
                setPlayers(finalPlayers);
                setDiscardPile(newDiscardPile);
                setRoundWinner(0);
                const sortedMelds = meldsWithJokers.map(meld => sortMeld(meld, round));
                setWinnerMelds(sortedMelds);
                setPlayerMelds([]);
                setBuildingPayMe(false);
                setSelectedCard(null);
                setCelebrationName(players[0].name);
                setShowCelebration(true);
                setMessage(`${players[0].name} declared "Pay Me"! Play continues in turn order.`);
                const nextIndex = 1 % players.length;
                const timeoutId = setTimeout(() => {
                    setCurrentPlayerIndex(nextIndex);
                    setGamePhase('finaldraw');
                }, 1500);
                timeoutRefs.current.push(timeoutId);
            };
            const discardForPayMe = (cardIndex) => {
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[0];
                const discardedCard = currentPlayer.hand.splice(cardIndex, 1)[0];
                const newDiscardPile = [...discardPile, discardedCard];
                const updatedMelds = playerMelds.map(meld =>
                    meld.filter(c => c.index !== cardIndex).map(c => {
                        const {index, ...cardWithoutIndex} = c;
                        return cardWithoutIndex;
                    })
                ).filter(meld => meld.length >= 3);
                const meldsWithJokers = updatedMelds.map(meld => {
                    const hasWilds = meld.some(card => isWild(card, round));
                    if (hasWilds) {
                        if (isValidRun(meld, round)) {
                            const meldWithAssignedWilds = assignJokersInRun(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        } else if (isValidSet(meld, round)) {
                            const meldWithAssignedWilds = assignWildsInSet(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        }
                    }
                    return sortMeld(meld, round);
                });
                updatedPlayers[0].melds = meldsWithJokers;
                updatedPlayers[0].hand = [];
                const finalPlayers = updatedPlayers.map((p, idx) => {
                    if (idx === 0) {
                        return { ...p, quarters: p.quarters + players.length - 1 };
                    } else {
                        return { ...p, quarters: p.quarters - 1 };
                    }
                });
                setPlayers(finalPlayers);
                setDiscardPile(newDiscardPile);
                setRoundWinner(0);
                setWinnerMelds(updatedMelds);
                setPlayerMelds([]);
                setSelectedCard(null);
                setCelebrationName(players[0].name);
                setShowCelebration(true);
                setMessage(`${players[0].name} declared "Pay Me"! Play continues in turn order.`);
                const nextIndex = 1 % players.length;
                const timeoutId = setTimeout(() => {
                    setCurrentPlayerIndex(nextIndex);
                    setGamePhase('finaldraw');
                }, 1500);
                timeoutRefs.current.push(timeoutId);
            };
            const nextTurn = () => {
                const nextIndex = (currentPlayerIndex + 1) % players.length;
                setCurrentPlayerIndex(nextIndex);
                setGamePhase('draw');
                if (!players[nextIndex].isAI) {
                    setMessage('Your turn - draw a card');
                } else {
                    setMessage(`${players[nextIndex].name}'s turn...`);
                }
            };
            const layDownMelds = () => {
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[currentPlayerIndex];
                const { melds, remaining } = findBestMelds(currentPlayer.hand, round);
                const duplicateCards = [];
                const cleanedMelds = melds.map(meld => {
                    const seenIds = new Set();
                    return meld.filter(card => {
                        if (seenIds.has(card.id)) {
                            console.warn(`Duplicate card ID detected in meld: ${card.rank}${card.suit} (${card.id})`);
                            duplicateCards.push(card);
                            return false;
                        }
                        seenIds.add(card.id);
                        return true;
                    });
                });
                const sortedMelds = cleanedMelds.map(meld => sortMeld(meld, round));
                currentPlayer.melds = sortedMelds;
                let leftoverCards = [...remaining, ...duplicateCards];
                if (!currentPlayer.playedOnCards) {
                    currentPlayer.playedOnCards = [];
                }
                if (roundWinner !== null && updatedPlayers[roundWinner].melds && updatedPlayers[roundWinner].melds.length > 0) {
                    let cardWasPlayed;
                    let loopCount = 0;
                    const MAX_LOOPS = 50;
                    do {
                        cardWasPlayed = false;
                        loopCount++;
                        if (loopCount > MAX_LOOPS) {
                            console.error('AI play-off loop exceeded MAX_LOOPS - breaking to prevent infinite loop');
                            break;
                        }
                        const winnerPlayer = updatedPlayers[roundWinner];
                        winnerPlayer.melds.forEach((meld, meldIdx) => {
                            const meldWithWilds = meld.map(c => ({
                                ...c,
                                isWildForRound: isWild(c, round),
                                ...(c.representsCard && { representsCard: c.representsCard })
                            }));
                            const meldIsSet = isValidSet(meldWithWilds, round);
                            const meldIsRun = !meldIsSet && isValidRun(meldWithWilds, round);
                            leftoverCards = leftoverCards.filter(card => {
                                const meldIsSet = isValidSet(meld.map(c => ({ ...c, isWildForRound: isWild(c, round) })), round);
                                const meldIsRun = !meldIsSet && isValidRun(meld.map(c => ({ ...c, isWildForRound: isWild(c, round) })), round);
                                if (meldIsRun && !isWild(card, round)) {
                                    const cardRankSuit = `${card.rank}${card.suit}`;
                                    const wildRepresentsThisCard = meld.some(c =>
                                        c.representsCard === cardRankSuit
                                    );
                                    if (wildRepresentsThisCard) {
                                        return true;
                                    }
                                    const cardRank = card.rank;
                                    const rankAlreadyExists = meld.some(c => {
                                        if (isWild(c, round) && c.representsCard) {
                                            const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                                            return match && match[1] === cardRank;
                                        }
                                        return c.rank === cardRank;
                                    });
                                    if (rankAlreadyExists) {
                                        return true;
                                    }
                                }
                                const testMeld = [
                                    ...meld.map(c => ({
                                        ...c,
                                        isWildForRound: isWild(c, round),
                                        ...(c.representsCard && { representsCard: c.representsCard })
                                    })),
                                    { ...card, isWildForRound: isWild(card, round) }
                                ];
                                let validAfterAdd = false;
                                if (meldIsSet) {
                                    validAfterAdd = isValidSet(testMeld, round);
                                } else if (meldIsRun) {
                    if (!canExtendRunOnEnd(meldWithWilds, card, round)) {
                        const meldType = 'run';
                        setMessage(`Can't add ${card.rank}${card.suit} to this run - must extend the run ends (same suit)`);
                        setDraggedCardIndex(null);
                        setDropTargetIndex(null);
                        return;
                    }
                    validAfterAdd = isValidRun(testMeld, round);
                                }
                                if (validAfterAdd) {
                                    const updatedMeld = [
                                        ...meld,
                                        {
                                            ...card,
                                            isWildForRound: isWild(card, round),
                                            addedBy: currentPlayer.avatar
                                        }
                                    ];
                                    let finalMeld = updatedMeld;
                                    if (meldIsRun && isWild(card, round)) {
                                        const nonWilds = meld.filter(c => !isWild(c, round) && !c.representsCard);
                                        const wildCards = meld.filter(c => isWild(c, round) || c.representsCard);
                                        const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                                        const ranks = meld.map(c => {
                                            if (c.representsCard) {
                                                return c.representsCard.slice(0, -1);
                                            }
                                            return c.rank;
                                        });
                                        const rankIndices = ranks.map(r => rankOrder.indexOf(r)).sort((a, b) => a - b);
                                        const hasAce = rankIndices.includes(0);
                                        const hasHighCards = rankIndices.some(idx => idx >= 10);
                                        let adjustedIndices = [...rankIndices];
                                        if (hasAce && hasHighCards) {
                                            const nonAceIndices = rankIndices.filter(idx => idx !== 0);
                                            const minNonAce = Math.min(...nonAceIndices);
                                            if (minNonAce >= 9) {
                                                adjustedIndices = nonAceIndices.concat([13]).sort((a, b) => a - b);
                                            }
                                        }
                                        const suit = nonWilds.length > 0 ? nonWilds[0].suit :
                                                     (wildCards.length > 0 && wildCards[0].representsCard) ?
                                                     wildCards[0].representsCard.slice(-1) : 'â™ ';
                                        const minRank = adjustedIndices[0];
                                        const maxRank = adjustedIndices[adjustedIndices.length - 1];
                                        let representsRank;
                                        let representsIndex;
                                        if (minRank > 0 && minRank - 1 < rankOrder.length) {
                                            representsIndex = minRank - 1;
                                            representsRank = rankOrder[representsIndex];
                                        } else if (maxRank < 13) {
                                            representsIndex = maxRank + 1;
                                            if (representsIndex === 13) {
                                                representsRank = 'A';
                                            } else {
                                                representsRank = rankOrder[representsIndex];
                                            }
                                        } else {
                                            console.error('Wild card cannot extend run at either end!');
                                            return true;
                                        }
                                        finalMeld = updatedMeld.map((c, idx) => {
                                            if (idx === updatedMeld.length - 1) {
                                                return { ...c, representsCard: `${representsRank}${suit}` };
                                            }
                                            return {...c};
                                        });
                                    } else if (meldIsSet && isWild(card, round)) {
                                        const nonWilds = updatedMeld.filter(c => !isWild(c, round));
                                        const setRank = nonWilds.length > 0 ? nonWilds[0].rank : null;
                                        if (setRank) {
                                            finalMeld = updatedMeld.map(c => {
                                                if (isWild(c, round)) {
                                                    return { ...c, representsCard: `${setRank}${c.suit}` };
                                                }
                                                return {...c};
                                            });
                                        }
                                    }
                                    const sortedMeld = sortMeld(finalMeld, round);
                                    const winnerNewMelds = [...updatedPlayers[roundWinner].melds];
                                    winnerNewMelds[meldIdx] = sortedMeld;
                                    updatedPlayers[roundWinner] = {
                                        ...updatedPlayers[roundWinner],
                                        melds: winnerNewMelds
                                    };
                                    const cardToTrack = {
                                        ...card,
                                        playedOn: `${winnerPlayer.name}'s meld ${meldIdx + 1}`,
                                        addedBy: currentPlayer.avatar
                                    };
                                    currentPlayer.playedOnCards.push(cardToTrack);
                                    cardWasPlayed = true;
                                    return false;
                                }
                                return true;
                            });
                        });
                    } while (cardWasPlayed);
                }
                if (leftoverCards.length === 0 && sortedMelds.length > 0) {
                    let largestMeldIdx = 0;
                    for (let i = 1; i < sortedMelds.length; i++) {
                        if (sortedMelds[i].length > sortedMelds[largestMeldIdx].length) {
                            largestMeldIdx = i;
                        }
                    }
                    const removedCard = sortedMelds[largestMeldIdx].pop();
                    leftoverCards.push(removedCard);
                    if (sortedMelds[largestMeldIdx].length < 3) {
                        leftoverCards.push(...sortedMelds[largestMeldIdx]);
                        sortedMelds.splice(largestMeldIdx, 1);
                    }
                    currentPlayer.melds = sortedMelds;
                }
                currentPlayer.hand = leftoverCards;
                if (currentPlayer.isAI && leftoverCards.length > 0) {
                    currentPlayer.dialogue = getDialogue(currentPlayer.character, 'lose');
                }
                setPlayers(updatedPlayers);
                setGamePhase('finaldiscard');
                setMessage('Click a card to discard');
            };
            const finalizeFinalMelds = () => {
                let meldsToValidate = [...playerMelds];
                if (currentMeld.length >= 3) {
                    const interpretations = getPossibleMeldInterpretations(currentMeld, round);
                    if (interpretations.allWilds) {
                        setMeldPickerAllWilds(true);
                        setMeldPickerStep(1);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    if (interpretations.options && interpretations.options.length > 1) {
                        setMeldPickerOptions(interpretations.options);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    if (currentMeld.length < 3) {
                        setMeldError('Current meld must have at least 3 cards. Please finish it or remove cards to continue.');
                        return;
                    }
                    const isSet = isValidSet(currentMeld, round);
                    const isRun = isValidRun(currentMeld, round);
                    if (!isSet && !isRun) {
                        setMeldError('Current meld is not a valid set or run. Please fix it or remove cards to continue.');
                        return;
                    }
                    meldsToValidate = [...playerMelds, [...currentMeld]];
                }
                for (let i = 0; i < meldsToValidate.length; i++) {
                    const meld = meldsToValidate[i];
                    if (!isValidSet(meld, round) && !isValidRun(meld, round)) {
                        setMeldError(`Meld ${i + 1} is invalid. All melds must be valid sets or runs.`);
                        return;
                    }
                }
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[0];
                const cardsInMelds = new Set();
                meldsToValidate.forEach(meld => meld.forEach(card => cardsInMelds.add(card.index)));
                const totalCards = currentPlayer.hand.length;
                const meldsCardCount = cardsInMelds.size;
                const cleanedMelds = meldsToValidate.map(meld =>
                    meld.map(c => {
                        const {index, ...cardWithoutIndex} = c;
                        return cardWithoutIndex;
                    })
                );
                const sortedMelds = cleanedMelds.map(meld => sortMeld(meld, round));
                currentPlayer.melds = sortedMelds;
                const cardsPlayedOnWinner = new Set();
                if (currentPlayer.playedOnCards) {
                    currentPlayer.playedOnCards.forEach(playedCard => {
                        const handIndex = currentPlayer.hand.findIndex(handCard =>
                            handCard.rank === playedCard.rank &&
                            handCard.suit === playedCard.suit &&
                            handCard.id === playedCard.id
                        );
                        if (handIndex !== -1) {
                            cardsPlayedOnWinner.add(handIndex);
                        }
                    });
                }
                const remainingHand = currentPlayer.hand.filter((card, idx) =>
                    !cardsInMelds.has(idx) && !cardsPlayedOnWinner.has(idx)
                );
                if (!validatePlayerCanEndTurn(currentPlayer, remainingHand)) {
                    setMeldError('Error: Must have at least 1 card left to discard');
                    return;
                }
                currentPlayer.hand = remainingHand;
                if (!currentPlayer.playedOnCards) {
                    currentPlayer.playedOnCards = [];
                }
                setPlayers(updatedPlayers);
                setPlayerMelds([]);
                setCurrentMeld([]);
                setMeldError('');
                setMeldBuildingComplete(true);
                if (remainingHand.length === 1) {
                    const lastCard = remainingHand[0];
                    updatedPlayers[0].hand = [];
                    const updatedDiscardPile = [...discardPile, lastCard];
                    setDiscardPile(updatedDiscardPile);
                    setPlayersWhoHaveTakenFinalTurn(prev => new Set([...prev, 0]));
                    const nextIndex = 1 % players.length;
                    if (nextIndex === roundWinner) {
                        setAllFinalPlaysComplete(true);
                    } else {
                        const points = 0;
                        setHumanFinalPlayResults({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [],
                            discard: lastCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        setShowingHumanFinalPlay(true);
                        const isNextHuman = !players[nextIndex].isAI;
                        const timeoutId = setTimeout(() => {
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                            if (isNextHuman) {
                                setMessage('Your final turn - draw a card');
                            } else {
                                setMessage(`${players[nextIndex].name}'s final turn...`);
                            }
                        }, 500);
                        timeoutRefs.current.push(timeoutId);
                    }
                } else {
                    setGamePhase('finaldiscard');
                    setMessage(`Click a card to discard (${remainingHand.length} cards left)`);
                }
            };
            const endRound = (currentPlayers, currentDealerIdx) => {
                setIsRoundTransitioning(true);
                setBuildingPayMe(false);
                setMeldBuildingComplete(true);
                nextFinalTurnActionRef.current = null;
                const updatedPlayers = currentPlayers.map((player, idx) => {
                    const roundScore = idx === roundWinner ? 0 : calculateScore(player.hand);
                    const newScore = player.score + roundScore;
                    const cleanMelds = player.melds.map(meld =>
                        meld.map(card => ({
                            rank: card.rank,
                            suit: card.suit,
                            isRed: card.isRed,
                            id: card.id,
                            representsCard: card.representsCard
                        }))
                    );
                    const cleanRemainingCards = player.hand.map(card => ({
                        rank: card.rank,
                        suit: card.suit,
                        isRed: card.isRed,
                        id: card.id
                    }));
                    const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                        rank: card.rank,
                        suit: card.suit,
                        isRed: card.isRed,
                        id: card.id,
                        playedOn: card.playedOn
                    }));
                    const roundData = {
                        round: round,
                        melds: cleanMelds,
                        remainingCards: cleanRemainingCards,
                        playedOnCards: cleanPlayedOnCards,
                        roundScore: roundScore,
                        runningScore: newScore,
                        wasWinner: idx === roundWinner
                    };
                    return {
                        ...player,
                        score: newScore,
                        roundHistory: [...(player.roundHistory || []), roundData]
                    };
                });
                setPlayers(updatedPlayers);
                if (round < 11) {
                    const nextDealerIdx = (currentDealerIdx + 1) % updatedPlayers.length;
                    setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                    const transitionToNextRound = () => {
                        const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                        setDealerIndex(nextDealerIdx);
                        setIsRoundTransitioning(false);
                        startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                        setRound(round + 1);
                    };
                    const timeoutId = setTimeout(() => {
                        if (isPausedRef.current) {
                            const checkInterval = setInterval(() => {
                                if (!isPausedRef.current) {
                                    clearInterval(checkInterval);
                                    transitionToNextRound();
                                }
                            }, 100);
                            intervalRefs.current.push(checkInterval);
                        } else {
                            transitionToNextRound();
                        }
                    }, 3000);
                    timeoutRefs.current.push(timeoutId);
                } else {
                    const winner = updatedPlayers.reduce((min, p) => p.score < min.score ? p : min);
                    setMessage(`Game Over! ${winner.name} wins with ${winner.score} points!`);
                    setGameOver(true);
                }
            };
            const autoLayoffForAI = (aiPlayerIndex) => {
                if (roundWinner === null || roundWinner === undefined) return;
                if (aiPlayerIndex === roundWinner) return;
                setPlayers(prevPlayers => {
                    const updatedPlayers = prevPlayers.map(p => ({
                        ...p,
                        hand: [...(p.hand || [])],
                        melds: (p.melds || []).map(m => [...m]),
                        playedOnCards: p.playedOnCards ? [...p.playedOnCards] : []
                    }));
                    const ai = updatedPlayers[aiPlayerIndex];
                    const winner = updatedPlayers[roundWinner];
                    if (!ai || !winner || !winner.melds || winner.melds.length === 0) return prevPlayers;
                    const rankOrder = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
                    const rankToIndex = r => rankOrder.indexOf(r);
                    const tryAddCardToMeld = (card, meldIndex, currentWinnerMelds) => {
                        const meld = currentWinnerMelds[meldIndex];
                        if (!meld || meld.length === 0) return { ok: false };
                        const meldWithWilds = meld.map(c => ({
                            ...c,
                            isWildForRound: isWild(c, round),
                            ...(c.representsCard && { representsCard: c.representsCard })
                        }));
                        const hasLockedRepresentations = meldWithWilds.some(c => c && c.representsCard);
                let meldIsSet = false;
                let meldIsRun = false;
                if (hasLockedRepresentations) {
                    meldIsRun = isValidRun(meldWithWilds, round);
                    meldIsSet = !meldIsRun && isValidSet(meldWithWilds, round);
                } else {
                    meldIsSet = isValidSet(meldWithWilds, round);
                    meldIsRun = !meldIsSet && isValidRun(meldWithWilds, round);
                }
                        if (!meldIsSet && !meldIsRun) return { ok: false };
                        const baseAdded = [...meld, { ...card, isWildForRound: isWild(card, round), addedBy: ai.avatar }];
                        if (meldIsRun && !isWild(card, round)) {
                            const cardRankSuit = `${card.rank}${card.suit}`;
                            const wildRepresentsThisCard = meld.some(c => c.representsCard === cardRankSuit);
                            if (wildRepresentsThisCard) return { ok: false };
                            const cardRank = card.rank;
                            const rankAlreadyExists = meld.some(c => {
                                if (isWild(c, round) && c.representsCard) {
                                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                                    return match && match[1] === cardRank;
                                }
                                return c.rank === cardRank;
                            });
                            if (rankAlreadyExists) return { ok: false };
                            const runSuit = (() => {
                                const nonWild = meld.find(c => !isWild(c, round));
                                if (nonWild) return nonWild.suit;
                                const wildWithRep = meld.find(c => c.representsCard);
                                if (wildWithRep) {
                                    const match = wildWithRep.representsCard.match(/([â™ â™¥â™¦â™£])$/);
                                    return match ? match[1] : null;
                                }
                                return null;
                            })();
                            if (runSuit && card.suit !== runSuit) {
                                return { ok: false };
                            }
                        }
                        if (meldIsRun && isWild(card, round)) {
                            const suit = (() => {
                                const nonWild = meld.find(c => !isWild(c, round));
                                if (nonWild) return nonWild.suit;
                                const rep = meld.find(c => c.representsCard);
                                const match = rep && rep.representsCard && rep.representsCard.match(/(â™ |â™¥|â™¦|â™£)$/);
                                return match ? match[1] : card.suit;
                            })();
                            const currentIndices = meld.map(c => {
                                if (isWild(c, round) && c.representsCard) {
                                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                                    return match ? rankToIndex(match[1]) : rankToIndex(c.rank);
                                }
                                return rankToIndex(c.rank);
                            }).filter(i => i >= 0);
                            if (currentIndices.length === 0) return { ok: false };
                            const hasAce = currentIndices.includes(0);
                            const hasHighCards = currentIndices.some(idx => idx >= 10);
                            let adjusted = [...currentIndices];
                            if (hasAce && hasHighCards) {
                                const minNonAce = Math.min(...currentIndices.filter(i => i !== 0));
                                if (minNonAce >= 9) adjusted = currentIndices.map(i => i === 0 ? 13 : i);
                            }
                            const min = Math.min(...adjusted);
                            const max = Math.max(...adjusted);
                            const options = [];
                            if (min > 0) options.push(rankOrder[min - 1]);
                            if (max < 12) options.push(rankOrder[max + 1]);
                            if (max === 12 && !adjusted.includes(13) && !adjusted.includes(0)) options.push('A');
                            for (const chosenRank of options) {
                                const candidate = [...baseAdded];
                                candidate[candidate.length - 1] = { ...candidate[candidate.length - 1], representsCard: `${chosenRank}${suit}` };
                                const sorted = sortMeld(candidate, round);
                                if (isValidRun(sorted.map(c => ({
                                    ...c,
                                    isWildForRound: isWild(c, round),
                                    ...(c.representsCard && { representsCard: c.representsCard })
                                })), round)) {
                                    return { ok: true, meld: sorted, playedCard: { ...card, representsCard: `${chosenRank}${suit}` } };
                                }
                            }
                            return { ok: false };
                        }
                        const sorted = sortMeld(baseAdded, round);
                        if (meldIsSet && isWild(card, round)) {
                            const nonWilds = sorted.filter(c => !isWild(c, round));
                            if (nonWilds.length > 0) {
                                const setRank = nonWilds[0].rank;
                                const wildIdx = sorted.findIndex(c => c.id === card.id);
                                if (wildIdx >= 0) {
                                    sorted[wildIdx] = { ...sorted[wildIdx], representsCard: `${setRank}${card.suit}` };
                                }
                            }
                        }
                        const sortedWithWilds = sorted.map(c => ({
                            ...c,
                            isWildForRound: isWild(c, round),
                            ...(c.representsCard && { representsCard: c.representsCard })
                        }));
                        const ok = meldIsSet ? isValidSet(sortedWithWilds, round) : isValidRun(sortedWithWilds, round);
                        if (!ok) return { ok: false };
                        return { ok: true, meld: sorted, playedCard: card };
                    };
                    const findOptimalLayoff = (hand, winnerMelds) => {
                        if (hand.length <= 1) return { plays: [], remainingHand: hand, winnerMelds: winnerMelds };
                        let bestSolution = {
                            plays: [],
                            remainingHand: hand,
                            winnerMelds: winnerMelds,
                            points: calculateScore(hand)
                        };
                        const tryAllCombinations = (currentHand, currentWinnerMelds, currentPlays, depth) => {
                            if (currentHand.length <= 1) {
                                const points = calculateScore(currentHand);
                                if (points < bestSolution.points) {
                                    bestSolution = {
                                        plays: [...currentPlays],
                                        remainingHand: [...currentHand],
                                        winnerMelds: currentWinnerMelds.map(m => [...m]),
                                        points: points
                                    };
                                }
                                return;
                            }
                            if (depth >= 10) {
                                const points = calculateScore(currentHand);
                                if (points < bestSolution.points) {
                                    bestSolution = {
                                        plays: [...currentPlays],
                                        remainingHand: [...currentHand],
                                        winnerMelds: currentWinnerMelds.map(m => [...m]),
                                        points: points
                                    };
                                }
                                return;
                            }
                            let foundAnyPlay = false;
                            for (let cardIdx = 0; cardIdx < currentHand.length; cardIdx++) {
                                const card = currentHand[cardIdx];
                                for (let meldIdx = 0; meldIdx < currentWinnerMelds.length; meldIdx++) {
                                    const result = tryAddCardToMeld(card, meldIdx, currentWinnerMelds);
                                    if (result.ok) {
                                        foundAnyPlay = true;
                                        const newHand = currentHand.filter((_, idx) => idx !== cardIdx);
                                        const newWinnerMelds = currentWinnerMelds.map((m, idx) =>
                                            idx === meldIdx ? result.meld : [...m]
                                        );
                                        const newPlays = [...currentPlays, {
                                            card: result.playedCard || card,
                                            meldIdx: meldIdx
                                        }];
                                        tryAllCombinations(newHand, newWinnerMelds, newPlays, depth + 1);
                                    }
                                }
                            }
                            if (!foundAnyPlay) {
                                const points = calculateScore(currentHand);
                                if (points < bestSolution.points) {
                                    bestSolution = {
                                        plays: [...currentPlays],
                                        remainingHand: [...currentHand],
                                        winnerMelds: currentWinnerMelds.map(m => [...m]),
                                        points: points
                                    };
                                }
                            }
                        };
                        tryAllCombinations(hand, winnerMelds, [], 0);
                        return bestSolution;
                    };
                    const optimalSolution = findOptimalLayoff(ai.hand, winner.melds);
                    ai.hand = optimalSolution.remainingHand;
                    winner.melds = optimalSolution.winnerMelds;
                    optimalSolution.plays.forEach(play => {
                        ai.playedOnCards.push({
                            ...play.card,
                            playedOn: `${winner.name}'s meld ${play.meldIdx + 1}`,
                            addedBy: ai.avatar
                        });
                    });
                    return updatedPlayers;
                });
            };
const processAITurn = () => {
                const player = players[currentPlayerIndex];
                if (!player || !player.isAI) return;
                if (gamePhase === 'draw' || gamePhase === 'finaldraw') {
                    const topDiscard = discardPile.length > 0 ? discardPile[discardPile.length - 1] : null;
                    const decision = makeAIDecision(player.hand, discardPile, round, deck.length);
                    let drawnCard;
                    if (decision.drawFromDiscard && topDiscard) {
                        drawnCard = topDiscard;
                        setMessage(`${player.name} took the ${topDiscard.rank}${topDiscard.suit} from the discard pile`);
                    } else {
                        drawnCard = null;
                        setMessage(`${player.name} drew from the deck`);
                    }
                    const playerWithDrawnCard = { ...player, justDrawnCard: drawnCard };
                    const updatedPlayers = [...players];
                    updatedPlayers[currentPlayerIndex] = playerWithDrawnCard;
                    setPlayers(updatedPlayers);
                    setAiDrawHighlight(decision.drawFromDiscard ? 'discard' : 'deck');
                    const timeoutId = setTimeout(() => setAiDrawHighlight(null), 900 / aiSpeed);
                    timeoutRefs.current.push(timeoutId);
                    drawCard(decision.drawFromDiscard);
                } else if (gamePhase === 'discard' || gamePhase === 'finaldiscard') {
                    if (gamePhase === 'finaldiscard') {
                        autoLayoffForAI(currentPlayerIndex);
                    }
                    const requiredCards = round + 2;
                    const { melds, remaining } = findBestMelds(player.hand, round, true);
                    const cardsInMelds = melds.reduce((sum, meld) => sum + meld.length, 0);
                    const canDeclarePayMe = cardsInMelds === requiredCards && player.hand.length === requiredCards + 1;
                    const shouldDeclarePayMe = canDeclarePayMe && (() => {
                        let shouldDeclare = true;
                        if (remaining.length === 1) {
                            const remainingValue = CARD_VALUES[remaining[0].rank] || 0;
                            if (remainingValue <= 5) shouldDeclare = true;
                        }
                        if (deck.length < 20) shouldDeclare = true;
                        const minOtherPlayerCards = Math.min(...players.filter((p, idx) => idx !== currentPlayerIndex).map(p => p.hand.length));
                        if (minOtherPlayerCards <= 4) shouldDeclare = true;
                        return shouldDeclare;
                    })();
                    if (shouldDeclarePayMe) {
                        const updatedPlayers = [...players];
                        let discardedCard;
                        if (remaining.length > 0) {
                            let worstIdx = 0;
                            let worstValue = -1;
                            remaining.forEach((card, idx) => {
                                const value = CARD_VALUES[card.rank] || 20;
                                if (value > worstValue) {
                                    worstValue = value;
                                    worstIdx = idx;
                                }
                            });
                            discardedCard = remaining[worstIdx];
                            const cardIndexInHand = updatedPlayers[currentPlayerIndex].hand.findIndex(
                                c => c.id === discardedCard.id
                            );
                            updatedPlayers[currentPlayerIndex].hand.splice(cardIndexInHand, 1);
                        } else {
                            discardedCard = updatedPlayers[currentPlayerIndex].hand.pop();
                        }
                        const newDiscardPile = [...discardPile, discardedCard];
                        const meldsWithJokers = melds.map(meld => {
                            const hasWilds = meld.some(card => isWild(card, round));
                            if (hasWilds && isValidRun(meld, round)) {
                                return assignJokersInRun(meld, round);
                            }
                            return meld;
                        });
                        updatedPlayers[currentPlayerIndex].melds = meldsWithJokers;
                        updatedPlayers[currentPlayerIndex].hand = [];
                        updatedPlayers[currentPlayerIndex].dialogue = getDialogue(updatedPlayers[currentPlayerIndex].character, 'payme');
                        const finalPlayers = updatedPlayers.map((p, idx) => {
                            if (idx === currentPlayerIndex) {
                                return { ...p, quarters: p.quarters + players.length - 1 };
                            } else {
                                return { ...p, quarters: p.quarters - 1 };
                            }
                        });
                        setPlayers(finalPlayers);
                        setDiscardPile(newDiscardPile);
                        setRoundWinner(currentPlayerIndex);
                        setWinnerMelds(melds);
                        setCelebrationName(player.name);
                        setShowCelebration(true);
                        setMessage(`${player.name} declared "Pay Me"! Play continues in turn order.`);
                        const nextIndex = (currentPlayerIndex + 1) % players.length;
                        const timeoutId = setTimeout(() => {
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                        }, 1500);
                        timeoutRefs.current.push(timeoutId);
                    } else {
                        const closeToPayMe = cardsInMelds >= requiredCards - 2;
                        if (closeToPayMe) {
                            let bestDiscardIndex = -1;
                            let worstScore = Infinity;
                            player.hand.forEach((card, idx) => {
                                const cardIsWild = isWild(card, round);
                                if (cardIsWild) {
                                    return;
                                }
                                let score = 0;
                                const sameRank = player.hand.filter(c => c.rank === card.rank).length;
                                if (sameRank >= 3) {
                                    score += 100;
                                } else if (sameRank === 2) {
                                    score += 50;
                                }
                                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                                const cardRankIdx = rankOrder.indexOf(card.rank);
                                const sameSuitNearby = player.hand.filter(c => {
                                    if (c.suit !== card.suit || c.id === card.id) return false;
                                    if (isWild(c, round)) return true;
                                    const otherRankIdx = rankOrder.indexOf(c.rank);
                                    return Math.abs(otherRankIdx - cardRankIdx) <= 2;
                                }).length;
                                if (sameSuitNearby >= 2) {
                                    score += 80;
                                } else if (sameSuitNearby === 1) {
                                    score += 30;
                                }
                                score -= (CARD_VALUES[card.rank] || 0);
                                if (score < worstScore) {
                                    worstScore = score;
                                    bestDiscardIndex = idx;
                                }
                            });
                            if (bestDiscardIndex >= 0) {
                                discardCard(bestDiscardIndex);
                            } else {
                                const justDrawnCard = player.justDrawnCard || (player.hand.length > 0 ? player.hand[player.hand.length - 1] : null);
                                const decision = makeAIDecision(player.hand, discardPile, round, deck.length, justDrawnCard);
                                discardCard(decision.discardIndex);
                            }
                        } else {
                            const justDrawnCard = player.justDrawnCard || (player.hand.length > 0 ? player.hand[player.hand.length - 1] : null);
                            const decision = makeAIDecision(player.hand, discardPile, round, deck.length, justDrawnCard);
                            discardCard(decision.discardIndex);
                        }
                    }
                } else if (gamePhase === 'finaldiscard') {
                    const justDrawnCard = player.justDrawnCard || (player.hand.length > 0 ? player.hand[player.hand.length - 1] : null);
                    const decision = makeAIDecision(player.hand, discardPile, round, deck.length, justDrawnCard);
                    discardCard(decision.discardIndex);
                } else if (gamePhase === 'finallaydown') {
                    const updatedPlayers = [...players];
                    const currentPlayer = updatedPlayers[currentPlayerIndex];
                    const { melds, remaining } = findBestMelds(currentPlayer.hand, round, true);
                    const duplicateCards = [];
                    const cleanedMelds = melds.map(meld => {
                        const seenIds = new Set();
                        return meld.filter(card => {
                            if (seenIds.has(card.id)) {
                                duplicateCards.push(card);
                                return false;
                            }
                            seenIds.add(card.id);
                            return true;
                        });
                    });
                    const sortedMelds = cleanedMelds.map(meld => sortMeld(meld, round));
                    currentPlayer.melds = sortedMelds;
                    let leftoverCards = [...remaining, ...duplicateCards];
                    if (leftoverCards.length === 0 && sortedMelds.length > 0) {
                        console.warn(`WARNING: ${currentPlayer.name} has no leftover cards after forming melds. This should have been prevented by findBestMelds with reserveForDiscard=true. Attempting recovery...`);
                        let smallestMeldIdx = 0;
                        let smallestSize = sortedMelds[0].length;
                        for (let i = 1; i < sortedMelds.length; i++) {
                            if (sortedMelds[i].length < smallestSize) {
                                smallestSize = sortedMelds[i].length;
                                smallestMeldIdx = i;
                            }
                        }
                        const smallestMeld = sortedMelds[smallestMeldIdx];
                        let lowestValueIdx = -1;
                        let lowestValue = Infinity;
                        for (let i = 0; i < smallestMeld.length; i++) {
                            const card = smallestMeld[i];
                            if (!isWild(card, round)) {
                                const value = CARD_VALUES[card.rank] || 0;
                                if (value < lowestValue) {
                                    lowestValue = value;
                                    lowestValueIdx = i;
                                }
                            }
                        }
                        if (lowestValueIdx === -1) {
                            lowestValueIdx = smallestMeld.length - 1;
                        }
                        const removedCard = smallestMeld.splice(lowestValueIdx, 1)[0];
                        leftoverCards.push(removedCard);
                        if (smallestMeld.length < 3) {
                            leftoverCards.push(...smallestMeld);
                            sortedMelds.splice(smallestMeldIdx, 1);
                        }
                        currentPlayer.melds = sortedMelds;
                    }
                    if (!currentPlayer.playedOnCards) {
                        currentPlayer.playedOnCards = [];
                    }
                    if (roundWinner !== null && updatedPlayers[roundWinner] && updatedPlayers[roundWinner].melds && updatedPlayers[roundWinner].melds.length > 0) {
                        const rankToValue = (rank, aceHigh=true) => {
                            if (rank === 'A') return aceHigh ? 14 : 1;
                            if (rank === 'K') return 13;
                            if (rank === 'Q') return 12;
                            if (rank === 'J') return 11;
                            return parseInt(rank, 10);
                        };
                        const valueToRank = (v) => {
                            if (v === 14 || v === 1) return 'A';
                            if (v === 13) return 'K';
                            if (v === 12) return 'Q';
                            if (v === 11) return 'J';
                            return String(v);
                        };
                        const parseRepresents = (rep) => {
                            if (!rep || typeof rep !== 'string') return null;
                            const suit = rep.slice(-1);
                            const rank = rep.slice(0, -1);
                            return { rank, suit };
                        };
                        const effectiveRankSuit = (c) => {
                            if (c.representsCard) {
                                const p = parseRepresents(c.representsCard);
                                if (p) return p;
                            }
                            return { rank: c.rank, suit: c.suit };
                        };
                        const getRunInfo = (meld) => {
                            const eff = meld.map(effectiveRankSuit);
                            const suit = eff.find(x => x.suit)?.suit || null;
                            let valuesHigh = eff.map(x => rankToValue(x.rank, true));
                            const hasAce = eff.some(x => x.rank === 'A');
                            if (hasAce) {
                                const nonAce = valuesHigh.filter(v => v !== 14);
                                if (nonAce.length && Math.min(...nonAce) <= 5) {
                                    valuesHigh = eff.map(x => rankToValue(x.rank, false));
                                }
                            }
                            const minV = Math.min(...valuesHigh);
                            const maxV = Math.max(...valuesHigh);
                            return { suit, minV, maxV, aceLow: valuesHigh.some(v => v === 1) };
                        };
                        const canPlayOnRun = (card, meld) => {
                            const info = getRunInfo(meld);
                            if (!info.suit) return null;
                            const neededLow = info.minV - 1;
                            const neededHigh = info.maxV + 1;
                            if (!isWild(card, round)) {
                                if (card.suit !== info.suit) return null;
                                const vHigh = rankToValue(card.rank, true);
                                const vLow = rankToValue(card.rank, false);
                                const v = info.aceLow ? vLow : vHigh;
                                if (v === neededLow || v === neededHigh) return { representsCard: null };
                                return null;
                            }
                            const candidates = [];
                            if (neededLow >= 1 && neededLow <= 14) candidates.push(neededLow);
                            if (neededHigh >= 1 && neededHigh <= 14) candidates.push(neededHigh);
                            if (!candidates.length) return null;
                            const v = candidates[0];
                            const repRank = valueToRank(v);
                            return { representsCard: `${repRank}${info.suit}` };
                        };
                        const canPlayOnSet = (card, meld) => {
                            const eff = meld.map(effectiveRankSuit);
                            const base = eff.find((x, idx) => !isWild(meld[idx], round));
                            const targetRank = base ? base.rank : null;
                            if (!targetRank) return isWild(card, round) ? { representsCard: null } : null;
                            if (!isWild(card, round)) {
                                return card.rank === targetRank ? { representsCard: null } : null;
                            }
                            return { representsCard: null };
                        };
                        const winnerPlayer = updatedPlayers[roundWinner];
                        let progressed = true;
                        let guard = 0;
                        while (progressed && guard++ < 100 && leftoverCards.length > 1) {
                            progressed = false;
                            for (let meldIdx = 0; meldIdx < winnerPlayer.melds.length; meldIdx++) {
                                const meld = winnerPlayer.melds[meldIdx];
                                const meldWithFlags = meld.map(c => ({ ...c, isWildForRound: isWild(c, round) }));
                                const hasLocked = meldWithFlags.some(c => !!c.representsCard);
                                const isRun = hasLocked ? isValidRun(meldWithFlags, round) : (!isValidSet(meldWithFlags, round) && isValidRun(meldWithFlags, round));
                                const isSet = hasLocked ? (!isRun && isValidSet(meldWithFlags, round)) : isValidSet(meldWithFlags, round);
                                for (let ci = 0; ci < leftoverCards.length; ci++) {
                                    if (leftoverCards.length <= 1) break;
                                    const card = leftoverCards[ci];
                                    let play = null;
                                    if (isRun) play = canPlayOnRun(card, meldWithFlags);
                                    else if (isSet) play = canPlayOnSet(card, meldWithFlags);
                                    if (play) {
                                        const playedCard = { ...card, addedBy: currentPlayer.avatar, playedOn: `${winnerPlayer.name}'s meld ${meldIdx + 1}` };
                                        if (isWild(card, round) && play.representsCard) {
                                            playedCard.representsCard = play.representsCard;
                                        }
                                        winnerPlayer.melds[meldIdx] = sortMeld([...winnerPlayer.melds[meldIdx], playedCard], round);
                                        leftoverCards.splice(ci, 1);
                                        currentPlayer.playedOnCards.push(playedCard);
                                        progressed = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    let discardedCard;
                    if (leftoverCards.length === 0) {
                        console.error(`CRITICAL ERROR: ${currentPlayer.name} (AI) has no cards left to discard! This should be impossible.`);
                        console.error('Attempting recovery by removing a card from a meld...');
                        if (currentPlayer.melds.length > 0) {
                            let smallestMeldIdx = 0;
                            let smallestSize = currentPlayer.melds[0].length;
                            for (let i = 1; i < currentPlayer.melds.length; i++) {
                                if (currentPlayer.melds[i].length < smallestSize) {
                                    smallestSize = currentPlayer.melds[i].length;
                                    smallestMeldIdx = i;
                                }
                            }
                            const meld = currentPlayer.melds[smallestMeldIdx];
                            let lowestValueIdx = -1;
                            let lowestValue = Infinity;
                            for (let i = 0; i < meld.length; i++) {
                                const card = meld[i];
                                if (!isWild(card, round)) {
                                    const value = CARD_VALUES[card.rank] || 0;
                                    if (value < lowestValue) {
                                        lowestValue = value;
                                        lowestValueIdx = i;
                                    }
                                }
                            }
                            if (lowestValueIdx === -1) lowestValueIdx = meld.length - 1;
                            const removedCard = meld.splice(lowestValueIdx, 1)[0];
                            leftoverCards.push(removedCard);
                            if (meld.length < 3) {
                                leftoverCards.push(...meld);
                                currentPlayer.melds.splice(smallestMeldIdx, 1);
                            }
                            console.log(`Recovered: Removed ${removedCard.rank}${removedCard.suit} for discard`);
                        }
                        if (leftoverCards.length === 0) {
                            console.error('Recovery failed - still no cards to discard!');
                            discardedCard = null;
                        } else {
                            discardedCard = leftoverCards.shift();
                        }
                    } else {
                        let bestDiscardIndex = 0;
                        let worstScore = Infinity;
                        leftoverCards.forEach((card, idx) => {
                            let score = 0;
                            if (isWild(card, round)) score += 1000;
                            score -= (CARD_VALUES[card.rank] || 0);
                            if (score < worstScore) {
                                worstScore = score;
                                bestDiscardIndex = idx;
                            }
                        });
                        discardedCard = leftoverCards.splice(bestDiscardIndex, 1)[0];
                    }
                    currentPlayer.hand = leftoverCards;
                    const newDiscardPile = discardedCard ? [...discardPile, discardedCard] : discardPile;
                    if (!discardedCard) {
                        console.error(`CRITICAL ERROR: ${currentPlayer.name} completed finallaydown without discarding a card! This violates game rules.`);
                        if (currentPlayer.hand.length > 0) {
                            discardedCard = currentPlayer.hand.pop();
                            newDiscardPile.push(discardedCard);
                            console.warn(`Emergency recovery: Forced discard of ${discardedCard.rank}${discardedCard.suit}`);
                        }
                    }
                    currentPlayer.dialogue = getDialogue(currentPlayer.character, 'discard');
                    setPlayers(updatedPlayers);
                    setDiscardPile(newDiscardPile);
                    setPlayersWhoHaveTakenFinalTurn(prev => new Set([...prev, currentPlayerIndex]));
                    const points = calculateScore(currentPlayer.hand);
                    setAiResultsToShow({
                        player: currentPlayer,
                        melds: currentPlayer.melds,
                        remaining: [...currentPlayer.hand],
                        discard: discardedCard,
                        points: points,
                        playedOnCards: currentPlayer.playedOnCards || []
                    });
                    setShowingAIMelds(true);
                    setMeldError('');
                    const nextIndex = (currentPlayerIndex + 1) % players.length;
                    if (nextIndex === roundWinner) {
                        nextFinalTurnActionRef.current = () => {
                            setShowingAIMelds(false);
                            setAiResultsToShow(null);
                            setHumanFinalPlayResults(null);
                            setAllFinalPlaysComplete(true);
                        };
                    } else {
                        const isNextHuman = !players[nextIndex].isAI;
                        nextFinalTurnActionRef.current = () => {
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                            if (isNextHuman) {
                                setMessage('Your final turn - draw a card');
                            } else {
                                setMessage(`${players[nextIndex].name}'s final turn...`);
                            }
                        };
                    }
                }
            };
            useEffect(() => {
                if (!gameStarted || players.length === 0 || !players[currentPlayerIndex]) return;
                if (pausedAfterPayMe) return;
                if (buildingPayMe) return;
                if (showingAIMelds) return;
                if (allFinalPlaysComplete) return;
                const currentPlayer = players[currentPlayerIndex];
                if (currentPlayer.isAI && !isPaused) {
                    const baseDelay = gamePhase === 'draw' || gamePhase === 'finaldraw' ? 1000 : 800;
                    const timer = setTimeout(() => processAITurn(), baseDelay / aiSpeed);
                    return () => clearTimeout(timer);
                }
            }, [currentPlayerIndex, gamePhase, gameStarted, isPaused, showingAIMelds, allFinalPlaysComplete, pausedAfterPayMe, buildingPayMe]);
            useEffect(() => {
                isPausedRef.current = isPaused;
            }, [isPaused]);
            useEffect(() => {
                return () => {
                    timeoutRefs.current.forEach(id => clearTimeout(id));
                    timeoutRefs.current = [];
                    intervalRefs.current.forEach(id => clearInterval(id));
                    intervalRefs.current = [];
                };
            }, []);
            if (!gameStarted) {
                return <GameSetup onStart={startGame} />;
            }
            const humanPlayer = players[0];
            const isHumanTurn = currentPlayerIndex === 0;
            const cardsInMelds = new Set();
            playerMelds.forEach(meld => meld.forEach(card => cardsInMelds.add(card.index)));
            const cardsInCurrentMeld = new Set(currentMeld.map(c => c.index));
            const cardsPlayedOnWinner = new Set();
            if (players[0] && players[0].playedOnCards) {
                players[0].playedOnCards.forEach(playedCard => {
                    const handIndex = players[0].hand.findIndex(handCard =>
                        handCard.rank === playedCard.rank &&
                        handCard.suit === playedCard.suit &&
                        handCard.id === playedCard.id
                    );
                    if (handIndex !== -1) {
                        cardsPlayedOnWinner.add(handIndex);
                    }
                });
            }
            return (
                <div className="game-container">
                    {showCelebration && (
                        <Celebration
                            playerName={celebrationName}
                            onClose={() => setShowCelebration(false)}
                        />
                    )}
                    {showDealerSelection && (
                        <div className="dealing-overlay">
                            <div className="dealing-content" style={{width: '100%', maxWidth: '800px', padding: '0 15px', boxSizing: 'border-box'}}>
                                <div className="dealer-announcement" style={{fontSize: 'clamp(24px, 6vw, 48px)'}}>ðŸŽ´ SELECTING DEALER ðŸŽ´</div>
                                <div className="dealing-info" style={{marginBottom: '20px', fontSize: 'clamp(14px, 4vw, 24px)'}}>Dealing cards to determine the dealer...</div>
                                <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: 'clamp(12px, 3vw, 24px)', maxWidth: '100%', margin: '0 auto', padding: '0 20px', boxSizing: 'border-box'}}>
                                    {players.map((player, idx) => (
                                        <div key={player.id} style={{
                                            textAlign: 'center',
                                            padding: 'clamp(8px, 2vw, 12px)',
                                            background: idx < dealerSelectionStep ? 'rgba(255,255,255,0.1)' : 'transparent',
                                            borderRadius: '8px',
                                            transition: 'all 0.3s',
                                            flexShrink: 0
                                        }}>
                                            <div style={{fontSize: 'clamp(18px, 5vw, 28px)', marginBottom: '8px'}}>{player.avatar}</div>
                                            <div style={{fontSize: 'clamp(11px, 2vw, 14px)', marginBottom: '12px', fontWeight: 'bold', wordBreak: 'break-word'}}>{player.name}</div>
                                            {player.dealerCard ? (
                                                <div style={{
                                                    display: 'flex',
                                                    justifyContent: 'center',
                                                    animation: 'cardFlip 0.5s ease-in-out'
                                                }}>
                                                    <Card card={{...player.dealerCard, isWildForRound: false}} disabled={true} />
                                                </div>
                                            ) : (
                                                <div style={{
                                                    width: 'clamp(70px, 9vw, 110px)',
                                                    height: 'clamp(105px, 13.5vw, 165px)',
                                                    margin: '0 auto',
                                                    border: '2px dashed rgba(255,255,255,0.3)',
                                                    borderRadius: '6px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    color: 'rgba(255,255,255,0.3)',
                                                    fontSize: '28px',
                                                    flexShrink: 0
                                                }}>
                                                    ?
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                    {showDealingAnimation && dealingInfo && (
                        <div className="dealing-overlay">
                            <div className="dealing-content">
                                <div className="dealer-announcement">ðŸŽ´ DEALING ðŸŽ´</div>
                                <div className="dealer-avatar">{dealingInfo.dealerAvatar}</div>
                                <div className="dealing-info">{dealingInfo.dealerName} is the dealer</div>
                                <div className="dealing-info">Round {dealingInfo.roundNum}</div>
                                <div className="dealing-info">Dealing {dealingInfo.cardsPerPlayer} cards to each player...</div>
                            </div>
                        </div>
                    )}
                    {showScoreDetails && scoreDetailsPlayer && (
                        <ScoreDetailsModal
                            player={scoreDetailsPlayer}
                            round={round}
                            onClose={() => { setShowScoreDetails(false); setScoreDetailsPlayer(null); }}
                        />
                    )}
                    {flyingCard && (
                        <div
                            className="flying-card"
                            style={{
                                left: flyingCard.endX,
                                top: flyingCard.endY,
                                width: flyingCard.width,
                                height: flyingCard.height,
                                transform: `translate(${flyingCard.startX - flyingCard.endX}px, ${flyingCard.startY - flyingCard.endY}px)`,
                                animation: 'cardFlip 0.6s ease-in-out'
                            }}
                        >
                            <Card card={{ ...flyingCard.card, isWildForRound: isWild(flyingCard.card, round) }} disabled={true} />
                        </div>
                    )}
                    {}
                    {flyingCardToWinner && (
                        <div
                            className="flying-card"
                            style={{
                                left: flyingCardToWinner.startX,
                                top: flyingCardToWinner.startY,
                                width: flyingCardToWinner.width,
                                height: flyingCardToWinner.height,
                                transition: 'left 0.3s ease-out, top 0.3s ease-out',
                                animation: 'none'
                            }}
                            ref={(el) => {
                                if (el) {
                                    requestAnimationFrame(() => {
                                        el.style.left = flyingCardToWinner.endX + 'px';
                                        el.style.top = flyingCardToWinner.endY + 'px';
                                    });
                                }
                            }}
                        >
                            <Card card={{ ...flyingCardToWinner.card, isWildForRound: isWild(flyingCardToWinner.card, round) }} disabled={true} />
                        </div>
                    )}
                    <div className="header">
                        <div className="header-top-row">
                            <h1><span>ðŸ’°</span><span>Pay Me</span></h1>
                            <div className="game-info">
                                <div className="info-item">
                                    <span className="info-label">Round</span>
                                    <span className="info-value">{round} of 11</span>
                                </div>
                                <div className="info-item">
                                    <span className="info-label">Cards</span>
                                    <span className="info-value">{round + 2}</span>
                                </div>
                                <div className="info-item">
                                    <span className="info-label">Wild Cards</span>
                                    <span className="info-value">{getWildCardName(round)} & Jokers</span>
                                </div>
                                <div className="info-item" style={{background: 'rgba(255, 215, 0, 0.1)', border: '2px solid #ffd700', borderRadius: '8px', padding: '8px 12px'}}>
                                    <span className="info-label">Dealer</span>
                                    <span className="info-value">{players[dealerIndex]?.avatar} {players[dealerIndex]?.name}</span>
                                </div>
                            </div>
                            <div className="header-message">
                                {message && (
                                    <div className={`message-pill ${roundWinner !== null ? 'success' : ''}`}>{message}</div>
                                )}
                                {isPaused && (
                                    <div className="message-pill warning">â¸ï¸ PAUSED</div>
                                )}
                            </div>
                            <div className="header-actions">
                                <button
                                    className="pause-button"
                                    onClick={() => setIsPaused(!isPaused)}
                                    title={isPaused ? "Resume" : "Pause"}
                                >
                                    {isPaused ? 'â–¶ï¸' : 'â¸ï¸'}
                                </button>
                            </div>
                        </div>
                    </div>
{isPaused && (
                        <div className="message-box" style={{background: '#ffc107', color: '#000', fontWeight: 'bold'}}>
                            â¸ï¸ GAME PAUSED - Click resume button to continue
                        </div>
                    )}
                    {meldError && !showingAIMelds && <div className="message-box error">{meldError}</div>}
                    <div className="game-content-wrapper">
                        {}
                        <div className={`side-panel ${sidePanelCollapsed ? 'collapsed' : ''}`}>
                            {}
                            <div style={{padding: '12px', background: '#f8f9fa', borderBottom: '2px solid #dee2e6', marginBottom: '8px'}}>
                                <div style={{display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '4px'}}>
                                    <label style={{fontSize: '12px', fontWeight: '600', color: '#495057', minWidth: '80px'}}>AI Speed:</label>
                                    <input
                                        type="range"
                                        min="0.5"
                                        max="3"
                                        step="0.5"
                                        value={aiSpeed}
                                        onChange={(e) => setAiSpeed(parseFloat(e.target.value))}
                                        style={{flex: 1, width: '100%'}}
                                    />
                                    <span style={{fontSize: '11px', fontWeight: 'bold', color: '#495057', minWidth: '55px'}}>
                                        {aiSpeed === 0.5 ? 'Slow' : aiSpeed === 1 ? 'Normal' : aiSpeed === 1.5 ? 'Fast' : aiSpeed === 2 ? 'Faster' : aiSpeed === 2.5 ? 'Very Fast' : 'Max'}
                                    </span>
                                </div>
                            </div>
                            <div className="players-grid">
                                {players.map((player, idx) => (
                                <div key={player.id} className={`player-card ${idx === currentPlayerIndex ? 'active' : ''} ${idx === roundWinner ? 'winner' : ''}`}>
                                    {}
                                    <div style={{
                                        position: 'absolute',
                                        top: '8px',
                                        right: '8px',
                                        background: 'linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%)',
                                        border: '2px solid #b8860b',
                                        borderRadius: '50%',
                                        width: '32px',
                                        height: '32px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontWeight: 'bold',
                                        fontSize: '13px',
                                        color: '#1a1a1a',
                                        boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
                                    }} title="Quarters">
                                        {player.quarters}
                                    </div>
                                    <div className="player-name">
                                        <span className="player-avatar">{player.avatar}</span>
                                        <span>
                                            {player.name}
                                            {idx === currentPlayerIndex && ' ðŸ‘ˆ'}
                                            {idx === dealerIndex && ' ðŸŽ´'}
                                        </span>
                                    </div>
                                    <div className="player-stats">
                                        <div onClick={() => { setScoreDetailsPlayer(player); setShowScoreDetails(true); }} style={{cursor: 'pointer'}}>
                                            Score: {player.score} ðŸ“Š
                                        </div>
                                    </div>
                                    {player.dialogue && <div className="player-dialogue">"{player.dialogue}"</div>}
                                    {}
                                    {!showDealingAnimation && roundWinner !== null && idx === 0 && playersWhoHaveTakenFinalTurn.has(idx) && (player.melds.length > 0 || player.hand.length > 0 || (player.playedOnCards && player.playedOnCards.length > 0)) && (
                                        <div className="player-final-hand">
                                            <div style={{display: 'flex', gap: '10px', flexWrap: 'wrap'}}>
                                                {player.melds.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Melds:</h5>
                                                        {player.melds.map((meld, meldIdx) => (
                                                            <div key={meldIdx} style={{display: 'flex', gap: '3px', marginBottom: '5px'}}>
                                                                {meld.map((card, cardIdx) => (
                                                                    <WinnerHandCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} showOriginalTag={false} />
                                                                ))}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {player.hand.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Remaining ({calculateScore(player.hand)} pts):</h5>
                                                        <div style={{display: 'flex', gap: '3px', flexWrap: 'wrap'}}>
                                                            {player.hand.map((card, cardIdx) => (
                                                                <WinnerHandCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} showOriginalTag={false} />
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                            {player.playedOnCards && player.playedOnCards.length > 0 && (
                                                <>
                                                    <h5>Played on Winner:</h5>
                                                    <div style={{display: 'flex', gap: '3px', flexWrap: 'wrap'}}>
                                                        {player.playedOnCards.map((card, cardIdx) => (
                                                            <WinnerHandCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} showOriginalTag={false} />
                                                        ))}
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    )}
                                    {}
                                    {!showDealingAnimation && roundWinner !== null && idx !== 0 && playersWhoHaveTakenFinalTurn.has(idx) && (player.melds.length > 0 || player.hand.length > 0) && (
                                        <div className="player-final-hand">
                                            <div style={{display: 'flex', gap: '10px', flexWrap: 'wrap'}}>
                                                {player.melds.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Melds:</h5>
                                                        {player.melds.map((meld, meldIdx) => (
                                                            <div key={meldIdx} className="mini-cards">
                                                                {meld.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                                ))}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {player.hand.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Remaining ({calculateScore(player.hand)} pts):</h5>
                                                        <div className="mini-cards">
                                                            {player.hand.map((card, cardIdx) => (
                                                                <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                            {player.playedOnCards && player.playedOnCards.length > 0 && (
                                                <>
                                                    <h5 style={{fontSize: '11px', color: '#17a2b8'}}>Played on Winner:</h5>
                                                    <div className="mini-cards">>
                                                        {player.playedOnCards.map((card, cardIdx) => (
                                                            <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                        ))}
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                        </div>
                        {}
                        <button
                            className={`side-panel-toggle ${sidePanelCollapsed ? '' : 'expanded'}`}
                            onClick={() => setSidePanelCollapsed(!sidePanelCollapsed)}
                            title={sidePanelCollapsed ? "Show Players" : "Hide Players"}
                        >
                            {sidePanelCollapsed ? 'â–¶' : 'â—€'}
                        </button>
                        {}
                        <div className="main-game-area">
                            {}
                            {roundWinner !== null && players[roundWinner].melds.length > 0 && !allFinalPlaysComplete && (
                                <div className="winner-hand-fixed">
                                    <div className="winner-hand-header-row"><h3 style={{marginBottom: '8px', fontSize: '16px'}}>{players[roundWinner].name}'s Winning Hand:</h3>{gamePhase === 'finallaydown' && !meldBuildingComplete && isHumanTurn && (
                                        <div className="winner-tip-pill">
                                            ðŸ’¡ Tip: Drag your cards from below and drop them on the green-bordered melds above to play them off!
                                        </div>
                                    )}</div>
                                    <div style={{display: 'flex', flexWrap: 'wrap', gap: '10px', alignItems: 'flex-start'}}>
                                    {players[roundWinner].melds.map((meld, idx) => {
                                        const isRun = isValidRun(meld, round);
                                        const displayMeld = isRun ? sortMeld(meld, round) : [...meld];
                                        return (
                                            <div
                                                key={idx}
                                                className="meld-group"
                                                onDragOver={(e) => {
                                                    const isSet = isValidSet(meld, round);
                                                    if (gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isSet)) {
                                                        e.preventDefault();
                                                        e.dataTransfer.dropEffect = 'copy';
                                                        hoveredWinnerMeldRef.current = idx;
                                                        setHoveredWinnerMeldIndex(idx);
                                                    }
                                                }}
                                                onDragLeave={(e) => {}}
                                                onDrop={(e) => {
                                                    e.preventDefault();
                                                    e.stopPropagation();
                                                }}
                                                style={{
                                                    border: gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isValidSet(meld, round)) ? '2px dashed #28a745' : '1px solid #dee2e6',
                                                    padding: '8px',
                                                    borderRadius: '6px',
                                                    background: '#f8f9fa',
                                                    display: 'inline-flex',
                                                    flexDirection: 'column',
                                                    gap: '4px'
                                                }}
                                            >
                                                <div style={{fontSize: '11px', fontWeight: '600', color: '#666', whiteSpace: 'nowrap'}}>
                                                    Meld {idx + 1}
                                                    {gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isValidSet(meld, round)) && (
                                                        <span style={{color: '#28a745', marginLeft: '6px', fontSize: '10px'}}>
                                                            â† drop to add
                                                        </span>
                                                    )}
                                                </div>
                                                <div
                                                    style={{display: 'flex', gap: '3px'}}
                                                    onDragEnter={(e) => {
                                                        const isSet = isValidSet(meld, round);
                                                        if (gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isSet)) {
                                                            e.preventDefault();
                                                            hoveredWinnerMeldRef.current = idx;
                                                            setHoveredWinnerMeldIndex(idx);
                                                        }
                                                    }}
                                                    onDragOver={(e) => {
                                                        const isSet = isValidSet(meld, round);
                                                        if (gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isSet)) {
                                                            e.preventDefault();
                                                            e.dataTransfer.dropEffect = 'copy';
                                                            hoveredWinnerMeldRef.current = idx;
                                                            setHoveredWinnerMeldIndex(idx);
                                                        }
                                                    }}
                                                    onDrop={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        hoveredWinnerMeldRef.current = idx;
                                                        setHoveredWinnerMeldIndex(idx);
                                                    }}
                                                >
                                                    {displayMeld.map((card, cardIdx) => (
                                                        <div
                                                            key={`${card.id}-${cardIdx}`}
                                                            draggable={gamePhase === 'finallaydown' && !meldBuildingComplete && card.addedBy}
                                                            onDragStart={(e) => {
                                                                if (card.addedBy) {
                                                                    e.dataTransfer.effectAllowed = 'move';
                                                                    e.dataTransfer.setData('winnerMeldIndex', idx);
                                                                    e.dataTransfer.setData('winnerMeldCardIndex', cardIdx);
                                                                }
                                                            }}
                                                            style={{cursor: card.addedBy ? 'grab' : 'default'}}
                                                        >
                                                            <MiniCard card={{ ...card, isWildForRound: isWild(card, round) }} isWinnerHand={true} />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        );
                                    })}
                                    </div>
                                </div>
                            )}
                        <div className="game-screen">
                        {}
                        {!showDealingAnimation && players.map((player, idx) => {
                            if (idx === 0) return null;
                            let position = 'top';
                            const opponentCount = players.length - 1;
                            if (opponentCount === 1) {
                                position = 'top';
                            } else if (opponentCount === 2) {
                                position = idx === 1 ? 'left' : 'right';
                            } else if (opponentCount >= 3) {
                                if (idx === 1) position = 'left';
                                else if (idx === 2) position = 'top';
                                else position = 'right';
                            }
                            const isWinner = idx === roundWinner;
                            const hasFinalPlay = playersWhoHaveTakenFinalTurn.has(idx) && roundWinner !== null && !allFinalPlaysComplete;
                            const showWinnerMelds = isWinner && player.melds.length > 0 && roundWinner !== null;
                            const isShowingAIResults = showingAIMelds && aiResultsToShow && aiResultsToShow.player.id === player.id;
                            const showCards = (hasFinalPlay && (player.melds.length > 0 || (player.playedOnCards && player.playedOnCards.length > 0) || player.hand.length > 0)) || showWinnerMelds || isShowingAIResults;
                            const displayMelds = isShowingAIResults ? aiResultsToShow.melds : player.melds;
                            const displayPlayedOn = isShowingAIResults ? aiResultsToShow.playedOnCards : player.playedOnCards;
                            const displayRemaining = isShowingAIResults ? aiResultsToShow.remaining : player.hand;
                            const displayPoints = isShowingAIResults ? aiResultsToShow.points : null;
                            return (
                                <div key={player.id} className={`table-player-position position-${position}`}>
                                    <div className={`table-player-info ${idx === currentPlayerIndex ? 'active' : ''}`}>
                                        <span className="table-player-avatar">{player.avatar}</span>
                                        <span className="table-player-name">
                                            {player.name}
                                            {idx === dealerIndex && ' ðŸŽ´'}
                                        </span>
                                    </div>
                                    {showCards ? (
                                        <div className="table-player-winner-cards">
                                            {displayMelds.length > 0 && (
                                                <div style={{display: 'inline-flex', flexDirection: 'column', gap: '4px', marginRight: '10px'}}>
                                                    {!isWinner && <div style={{fontSize: '11px', fontWeight: '600', color: '#28a745'}}>Melds:</div>}
                                                    <div style={{display: 'flex', gap: '5px'}}>
                                                        {displayMelds.map((meld, meldIdx) => {
                                                            const isRun = isValidRun(meld, round);
                                                            const isSet = isValidSet(meld, round);
                                                            const canDrop = isWinner && gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isSet);
                                                            return (
                                                                <div
                                                                    key={`meld-${meldIdx}`}
                                                                    className={`meld-group ${canDrop ? 'can-drop' : ''}`}
                                                                    onDragOver={(e) => {
                                                                        if (canDrop) {
                                                                            e.preventDefault();
                                                                            e.dataTransfer.dropEffect = 'copy';
                                                                            hoveredWinnerMeldRef.current = meldIdx;
                                                                            setHoveredWinnerMeldIndex(meldIdx);
                                                                        }
                                                                    }}
                                                                    onDrop={(e) => {
                                                                        if (canDrop) {
                                                                            e.preventDefault();
                                                                            e.stopPropagation();
                                                                            hoveredWinnerMeldRef.current = meldIdx;
                                                                            setHoveredWinnerMeldIndex(meldIdx);
                                                                        }
                                                                    }}
                                                                    style={{display: 'inline-flex', gap: '3px', background: 'rgba(40, 167, 69, 0.1)', border: '2px solid #28a745'}}
                                                                >
                                                                    {meld.map((card, cardIdx) => (
                                                                        isWinner ? (
                                                                            <WinnerHandCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                                        ) : (
                                                                            <Card key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} disabled={true} />
                                                                        )
                                                                    ))}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            )}
                                            {displayPlayedOn && displayPlayedOn.length > 0 && (
                                                <div style={{display: 'inline-flex', flexDirection: 'column', gap: '4px', marginRight: '10px'}}>
                                                    <div style={{fontSize: '11px', fontWeight: '600', color: '#17a2b8'}}>Played on Winner:</div>
                                                    <div className="meld-group" style={{background: 'rgba(23, 162, 184, 0.1)', border: '2px solid #17a2b8', display: 'inline-flex', gap: '3px'}}>
                                                        {displayPlayedOn.map((card, cardIdx) => (
                                                            <WinnerHandCard key={`played-${cardIdx}`} card={{...card, isWildForRound: isWild(card, round)}} showOriginalTag={false} />
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                            {displayRemaining.length > 0 && (
                                                <div style={{display: 'inline-flex', flexDirection: 'column', gap: '4px'}}>
                                                    <div style={{fontSize: '11px', fontWeight: '600', color: '#dc3545'}}>Remaining ({displayPoints !== null ? displayPoints : calculateScore(displayRemaining)} pts):</div>
                                                    <div className="meld-group" style={{background: 'rgba(220, 53, 69, 0.1)', border: '2px solid #dc3545', display: 'inline-flex', gap: '3px'}}>
                                                        {displayRemaining.map((card, cardIdx) => (
                                                            <WinnerHandCard key={`hand-${cardIdx}`} card={{...card, isWildForRound: isWild(card, round)}} showOriginalTag={false} />
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    ) : (
                                        <div className="table-player-cards">
                                            {player.hand.map((card, cardIdx) => (
                                                <div key={cardIdx} className="card face-down"></div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                        {isRoundTransitioning && (
                            <div style={{padding: '20px', textAlign: 'center', color: 'white', fontWeight: 'bold'}}>
                                Starting next round...
                            </div>
                        )}
                        {!buildingPayMe && gamePhase !== 'finallaydown' && !showingAIMelds && !showDealingAnimation && !allFinalPlaysComplete && (
                            <div className="deck-area">
                                <div className={`deck-pile ${aiDrawHighlight === 'deck' ? 'ai-highlight' : ''}`}>
                                    <div className="pile-label">Deck ({deck.length})</div>
                                    <div className={`card-stack ${!isHumanTurn || (gamePhase !== 'draw' && gamePhase !== 'finaldraw') ? 'disabled' : ''}`}
                                         onClick={() => isHumanTurn && (gamePhase === 'draw' || gamePhase === 'finaldraw') && drawCard(false)}>
                                        ðŸ‚ 
                                    </div>
                                </div>
                                <div className={`discard-pile ${aiDrawHighlight === 'discard' ? 'ai-highlight' : ''}`}>
                                    <div className="pile-label">Discard</div>
                                    {discardPile.length > 0 ? (
                                        <Card
                                            card={discardPile[discardPile.length - 1]}
                                            onClick={() => isHumanTurn && (gamePhase === 'draw' || gamePhase === 'finaldraw') && discardPile.length > 0 && drawCard(true)}
                                            disabled={!isHumanTurn || (gamePhase !== 'draw' && gamePhase !== 'finaldraw')}
                                        />
                                    ) : (
                                        <div className={`card-stack disabled`}>
                                            Empty
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                        {(buildingPayMe || (gamePhase === 'finallaydown' && !meldBuildingComplete && isHumanTurn)) && (
                            <div className="meld-building-area">
                                {}
                                {false && showingAIMelds && aiResultsToShow && roundWinner !== null && !allFinalPlaysComplete ? (
                                    <>
                                        <h3>{aiResultsToShow.player.avatar} {aiResultsToShow.player.name}'s Final Play</h3>
                                        <div style={{flex: '1', minHeight: '0', overflowX: 'auto', overflowY: 'auto', marginBottom: '15px', WebkitOverflowScrolling: 'touch'}}>
                                            <div style={{display: 'flex', gap: '8px', alignItems: 'flex-start', whiteSpace: 'nowrap'}}>
                                                {}
                                                {aiResultsToShow.melds.length > 0 && (
                                                    <>
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#28a745', whiteSpace: 'nowrap'}}>Melds:</h5>
                                                        <div style={{display: 'flex', gap: '6px'}}>
                                                            {aiResultsToShow.melds.map((meld, meldIdx) => (
                                                                <div key={meldIdx} style={{
                                                                    display: 'flex',
                                                                    gap: '3px',
                                                                    padding: '4px',
                                                                    border: '2px solid #28a745',
                                                                    borderRadius: '4px',
                                                                    background: 'rgba(40, 167, 69, 0.05)'
                                                                }}>
                                                                    {meld.map((card, cardIdx) => (
                                                                        <div key={`${meldIdx}-${cardIdx}`} style={{display: 'inline-block', flexShrink: 0}}>
                                                                            <WinnerHandCard
                                                                                card={{ ...card, isWildForRound: isWild(card, round) }}
                                                                                showOriginalTag={false}
                                                                            />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    {(aiResultsToShow.playedOnCards?.length > 0 || aiResultsToShow.remaining.length > 0) && (
                                                        <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                    )}
                                                    </>
                                                )}
                                                {}
                                                {aiResultsToShow.playedOnCards && aiResultsToShow.playedOnCards.length > 0 && (
                                                    <>
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#17a2b8', whiteSpace: 'nowrap'}}>Played on Winner:</h5>
                                                        <div style={{
                                                            display: 'flex',
                                                            gap: '3px',
                                                            padding: '4px',
                                                            border: '2px solid #17a2b8',
                                                            borderRadius: '4px',
                                                            background: 'rgba(23, 162, 184, 0.05)'
                                                        }}>
                                                            {aiResultsToShow.playedOnCards.map((card, idx) => (
                                                                <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                    <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round), addedBy: card.addedBy }} showOriginalTag={false} />
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    {(aiResultsToShow.remaining.length > 0 || aiResultsToShow.discard) && (
                                                        <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                    )}
                                                    </>
                                                )}
                                                {}
                                                {aiResultsToShow.remaining.length > 0 && (
                                                    <>
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#dc3545', whiteSpace: 'nowrap'}}>
                                                            Remaining ({aiResultsToShow.points} pts):
                                                        </h5>
                                                        <div style={{
                                                            display: 'flex',
                                                            gap: '4px',
                                                            padding: '4px',
                                                            border: '2px solid #dc3545',
                                                            borderRadius: '4px',
                                                            background: 'rgba(220, 53, 69, 0.05)'
                                                        }}>
                                                            {aiResultsToShow.remaining.map((card, idx) => (
                                                                <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                    <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    {aiResultsToShow.discard && (
                                                        <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                    )}
                                                    </>
                                                )}
                                                {}
                                                {aiResultsToShow.discard && (
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#6c757d', whiteSpace: 'nowrap'}}>Discarded:</h5>
                                                        <div style={{
                                                            display: 'flex',
                                                            gap: '3px',
                                                            padding: '4px',
                                                            border: '2px solid #6c757d',
                                                            borderRadius: '4px',
                                                            background: 'rgba(108, 117, 125, 0.05)'
                                                        }}>
                                                            <div style={{display: 'inline-block', flexShrink: 0}}>
                                                                <WinnerHandCard card={{ ...aiResultsToShow.discard, isWildForRound: isWild(aiResultsToShow.discard, round) }} showOriginalTag={false} />
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                        <div style={{marginTop: 'auto', paddingTop: '12px', display: 'flex', gap: '10px', justifyContent: 'flex-end'}}>
                                            {(() => {
                                                const nextIndex = (currentPlayerIndex + 1) % players.length;
                                                const isLastPlayer = nextIndex === roundWinner;
                                                return (
                                                    <>
                                                        {isLastPlayer && (
                                                            <button
                                                                className="success"
                                                                onClick={() => {
                                                                    openScoreboard();
                                                                }}
                                                                style={{fontSize: '14px', padding: '8px 16px'}}
                                                            >
                                                                Show Scoreboard
                                                            </button>
                                                        )}
                                                        <button
                                                            className="success"
                                                            onClick={() => {
                                                                if (isLastPlayer) {
                                                                    const winnerIdx = roundWinner;
                                                                    setShowingAIMelds(false);
                                                                    setAiResultsToShow(null);
                                                                    setShowingHumanFinalPlay(false);
                                                                    setHumanFinalPlayResults(null);
                                                                    setAllFinalPlaysComplete(false);
                                                                    setPlayersWhoHaveTakenFinalTurn(new Set());
                                                                    setRoundWinner(null);
                                                                    nextFinalTurnActionRef.current = null;
                                                                    if (round < 11) {
                                                                        const updatedPlayers = players.map((player, idx) => {
                                                                            const roundScore = idx === winnerIdx ? 0 : calculateScore(player.hand);
                                                                            const newScore = player.score + roundScore;
                                                                            const cleanMelds = player.melds.map(meld =>
                                                                                meld.map(card => ({
                                                                                    rank: card.rank,
                                                                                    suit: card.suit,
                                                                                    isRed: card.isRed,
                                                                                    id: card.id,
                                                                                    representsCard: card.representsCard
                                                                                }))
                                                                            );
                                                                            const cleanRemainingCards = player.hand.map(card => ({
                                                                                rank: card.rank,
                                                                                suit: card.suit,
                                                                                isRed: card.isRed,
                                                                                id: card.id
                                                                            }));
                                                                            const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                                                                                rank: card.rank,
                                                                                suit: card.suit,
                                                                                isRed: card.isRed,
                                                                                id: card.id,
                                                                                playedOn: card.playedOn
                                                                            }));
                                                                            const roundData = {
                                                                                round: round,
                                                                                melds: cleanMelds,
                                                                                remainingCards: cleanRemainingCards,
                                                                                playedOnCards: cleanPlayedOnCards,
                                                                                roundScore: roundScore,
                                                                                runningScore: newScore,
                                                                                wasWinner: idx === winnerIdx
                                                                            };
                                                                            return {
                                                                                ...player,
                                                                                score: newScore,
                                                                                hand: [],
                                                                                melds: [],
                                                                                playedOnCards: [],
                                                                                roundHistory: [...(player.roundHistory || []), roundData]
                                                                            };
                                                                        });
                                                                        const nextDealerIdx = (dealerIndex + 1) % updatedPlayers.length;
                                                                        const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                                                                        setPlayers(updatedPlayers);
                                                                        setDealerIndex(nextDealerIdx);
                                                                        setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                                                                        startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                                                                        setRound(round + 1);
                                                                    }
                                                                } else {
                                                                    setShowingAIMelds(false);
                                                                    setAiResultsToShow(null);
                                                                    if (nextFinalTurnActionRef.current) {
                                                                        nextFinalTurnActionRef.current();
                                                                        nextFinalTurnActionRef.current = null;
                                                                    }
                                                                }
                                                            }}
                                                            style={{fontSize: '14px', padding: '8px 16px'}}
                                                        >
                                                            {isLastPlayer ? 'Next Round' : 'Continue'}
                                                        </button>
                                                    </>
                                                );
                                            })()}
                                        </div>
                                    </>
                                ) : (
                                    <>
                                        <div className="meld-building-title-row" style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: '15px', flexWrap: 'wrap'}}>
                                            <h3 style={{margin: 0}}>
                                                {buildingPayMe ? 'Build Your Pay Me Melds' :
                                                 isHumanTurn ? (
                                                    <>
                                                        Build Your Final Melds
                                                        <span
                                                            style={{
                                                                marginLeft: '8px',
                                                                fontSize: '14px',
                                                                cursor: 'help',
                                                                opacity: 0.7
                                                            }}
                                                            title="Click cards below to build melds. Build any valid melds (3+ cards each). Leftover cards will count against you."
                                                        >
                                                            â„¹ï¸
                                                        </span>
                                                    </>
                                                 ) :
                                                 `${players[currentPlayerIndex]?.name} is Building Melds...`}
                                            </h3>
                                            {}
                                            {isHumanTurn && gamePhase === 'finallaydown' && !buildingPayMe && !showingHumanFinalPlay && (
                                                <button className="success" onClick={finalizeFinalMelds}>Finalize Melds and Discard</button>
                                            )}
                                            {}
                                            {buildingPayMe && (
                                                <div style={{display: 'flex', gap: '10px'}}>
                                                    <button className="success" onClick={finalizePayMe}>
                                                        Finalize & Discard
                                                    </button>
                                                    <button className="danger" onClick={cancelPayMeDeclaration}>Cancel</button>
                                                </div>
                                            )}
                                        </div>
                                        {}
                                        {buildingPayMe && (
                                            <div className="meld-building-subtitle">
                                                You need exactly {round + 2} cards in valid melds (3+ cards each). The remaining card will be automatically discarded.
                                            </div>
                                        )}
                                        {!isHumanTurn && !buildingPayMe && (
                                            <div className="meld-building-subtitle">
                                                {players[currentPlayerIndex]?.name} is organizing their cards into melds and playing off on {players[roundWinner]?.name}'s winning hand...
                                            </div>
                                        )}
                                        {}
                                        {!isHumanTurn && players[currentPlayerIndex]?.melds && players[currentPlayerIndex].melds.length > 0 && (
                                            <div style={{marginBottom: '15px', padding: '10px', background: '#e7f5ff', borderRadius: '8px', border: '2px solid #4dabf7'}}>
                                                <h4 style={{margin: '0 0 10px 0', fontSize: '14px', color: '#1971c2'}}>
                                                    {players[currentPlayerIndex].name}'s Melds:
                                                </h4>
                                                <div style={{display: 'flex', gap: '10px', overflowX: 'auto', WebkitOverflowScrolling: 'touch', flexWrap: 'nowrap'}}>
                                                    {players[currentPlayerIndex].melds.map((meld, idx) => (
                                                        <div key={idx} style={{
                                                            background: 'white',
                                                            border: '2px solid #4dabf7',
                                                            borderRadius: '6px',
                                                            padding: '8px',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            gap: '6px'
                                                        }}>
                                                            <span style={{fontSize: '11px', fontWeight: 'bold', color: '#1971c2'}}>Meld {idx + 1}:</span>
                                                            <div style={{display: 'flex', gap: '2px'}}>
                                                                {meld.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{ ...card, isWildForRound: isWild(card, round) }} />
                                                                ))}
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        {}
                                        <div className="meld-building-content">
                                            {}
                                            <div className={`current-meld-section ${playerMelds.length > 0 ? 'with-saved-melds' : ''}`}>
                                                <div className="meld-group">
                                                    <div className="meld-header">
                                                        <div className="meld-label">Current Meld: {currentMeld.length} cards</div>
                                                        {currentMeld.length >= 3 && (
                                                            <button className="success" onClick={saveCurrentMeld}>Save This Meld</button>
                                                        )}
                                                    </div>
                                                    <div className="cards-container" style={{minHeight: '120px', border: currentMeld.length === 0 ? '2px dashed #ccc' : 'none', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
                                                        {currentMeld.length === 0 ? (
                                                            <div style={{color: '#999', fontSize: '14px', textAlign: 'center'}}>
                                                                Click cards below to add them to this meld
                                                            </div>
                                                        ) : (
                                                            currentMeld.map((card, cardIdx) => (
                                                                <React.Fragment key={card.id || `${card.rank}${card.suit}-${cardIdx}`}>
                                                                    {}
                                                                    {dropTargetMeldIndex === cardIdx && draggedMeldCardIndex !== null && (
                                                                        <div className="card-insertion-indicator"></div>
                                                                    )}
                                                                    <Card
                                                                        card={{ ...card, isWildForRound: isWild(card, round) }}
                                                                        draggable={true}
                                                                        isDragging={draggedMeldCardIndex === cardIdx}
                                                                        onDragStart={(e) => handleMeldDragStart(e, cardIdx)}
                                                                        onDragOver={(e) => handleMeldDragOver(e, cardIdx)}
                                                                        onDrop={(e) => handleMeldDrop(e, cardIdx)}
                                                                        onDragEnd={() => handleMeldDragEnd()}
                                                                        onTouchStart={(e) => handleMeldTouchStart(e, cardIdx)}
                                                                        onTouchMove={(e) => handleMeldTouchMove(e, cardIdx)}
                                                                        onTouchEnd={(e) => handleMeldTouchEnd(e, cardIdx)}
                                                                        onClick={() => {
                                                                            if (isWild(card, round)) {
                                                                                assignWildCard(cardIdx);
                                                                            }
                                                                        }}
                                                                        onDoubleClick={() => {
                                                                            const updatedPlayers = [...players];
                                                                            if (!updatedPlayers[0].hand.some(c => c.id === card.id)) {
                                                                                updatedPlayers[0].hand.push(card);
                                                                            }
                                                                            setPlayers(updatedPlayers);
                                                                            setCurrentMeld(currentMeld.filter((_, i) => i !== cardIdx));
                                                                            setMessage('Card returned to hand');
                                                                        }}
                                                                        disabled={false}
                                                                    />
                                                                    {}
                                                                    {cardIdx === currentMeld.length - 1 && dropTargetMeldIndex === currentMeld.length && draggedMeldCardIndex !== null && (
                                                                        <div className="card-insertion-indicator"></div>
                                                                    )}
                                                                </React.Fragment>
                                                            ))
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                            {}
                                            {isHumanTurn && playerMelds.length > 0 && (
                                                <div className="your-melds-section">
                                                    {playerMelds.map((meld, idx) => (
                                                        <div key={idx} className="saved-meld-item">
                                                            <div style={{
                                                                background: 'white',
                                                                border: '2px solid #28a745',
                                                                borderRadius: '8px',
                                                                padding: '8px',
                                                                display: 'flex',
                                                                flexDirection: 'column',
                                                                gap: '8px',
                                                                height: '100%'
                                                            }}>
                                                                <div style={{
                                                                    display: 'flex',
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    marginBottom: '4px'
                                                                }}>
                                                                    <span style={{fontSize: '12px', fontWeight: 'bold', color: '#28a745'}}>Meld #{idx + 1}</span>
                                                                    <div style={{display: 'flex', gap: '4px'}}>
                                                                        <button
                                                                            onClick={() => {
                                                                                setCurrentMeld([...meld]);
                                                                                const updatedMelds = playerMelds.filter((_, i) => i !== idx);
                                                                                setPlayerMelds(updatedMelds);
                                                                                setMessage(`Editing meld #${idx + 1}`);
                                                                            }}
                                                                            style={{
                                                                                background: '#007bff',
                                                                                color: 'white',
                                                                                border: 'none',
                                                                                borderRadius: '4px',
                                                                                padding: '3px 7px',
                                                                                fontSize: '11px',
                                                                                cursor: 'pointer',
                                                                                fontWeight: 'bold'
                                                                            }}
                                                                            title="Edit this meld"
                                                                        >âœŽ</button>
                                                                        <button
                                                                            onClick={() => removeMeld(idx)}
                                                                            style={{
                                                                                background: '#dc3545',
                                                                                color: 'white',
                                                                                border: 'none',
                                                                                borderRadius: '4px',
                                                                                padding: '3px 7px',
                                                                                fontSize: '11px',
                                                                                cursor: 'pointer',
                                                                                fontWeight: 'bold'
                                                                            }}
                                                                            title="Delete this meld"
                                                                        >Ã—</button>
                                                                    </div>
                                                                </div>
                                                                <div style={{
                                                                    display: 'flex',
                                                                    gap: '4px',
                                                                    flexWrap: 'nowrap',
                                                                    justifyContent: 'flex-start',
                                                                    flex: 1,
                                                                    overflowX: 'auto'
                                                                }}>
                                                                    {meld.map((card, cardIdx) => (
                                                                        <div
                                                                            key={cardIdx}
                                                                            style={{cursor: 'pointer'}}
                                                                            onClick={() => {
                                                                                const updatedPlayers = [...players];
                                                                                if (!updatedPlayers[0].hand.some(c => c.id === card.id)) {
                                                                                    updatedPlayers[0].hand.push(card);
                                                                                }
                                                                                const updatedMelds = [...playerMelds];
                                                                                updatedMelds[idx] = meld.filter((_, i) => i !== cardIdx);
                                                                                if (updatedMelds[idx].length < 3) {
                                                                                    updatedMelds[idx].forEach(c => updatedPlayers[0].hand.push(c));
                                                                                    updatedMelds.splice(idx, 1);
                                                                                }
                                                                                setPlayers(updatedPlayers);
                                                                                setPlayerMelds(updatedMelds);
                                                                                setMessage('Card returned to hand');
                                                                            }}
                                                                        >
                                                                            <Card card={{ ...card, isWildForRound: isWild(card, round) }} disabled={true} />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>
                        )}
                        {}
                        {(humanPlayer.hand.length > 0 || humanFinalPlayResults) && !showingHumanFinalPlay && !allFinalPlaysComplete && (
                            <div
                                className="hand-area sticky-hand"
                                onDragOver={(e) => {
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'move';
                                }}
                                onDrop={handleDropBackToHand}
                            >
                                <div className="hand-label">
                                    Your Hand:
                                    {(buildingPayMe || (isHumanTurn && gamePhase === 'finallaydown' && !meldBuildingComplete)) && (
                                        <span style={{color: '#666', fontSize: '12px', marginLeft: '10px'}}>
                                            (Drag cards from melds back here to undo)
                                        </span>
                                    )}
                                </div>
                                {isHumanTurn && !buildingPayMe && gamePhase === 'discard' && (
                                    <div style={{textAlign: 'center', marginBottom: '10px'}}>
                                        <button onClick={startPayMeDeclaration} style={{fontSize: '16px', padding: '10px 24px'}}>Declare "Pay Me"!</button>
                                    </div>
                                )}
                                <div
                                    className="cards-container"
                                    onDragOver={(e) => {
                                        e.preventDefault();
                                        e.dataTransfer.dropEffect = 'move';
                                    }}
                                    onDrop={(e) => {
                                        const winnerMeldIndex = e.dataTransfer.getData('winnerMeldIndex');
                                        if (winnerMeldIndex !== '') {
                                            handleDropBackToHand(e);
                                            return;
                                        }
                                        if (dropTargetIndex !== null && draggedCardIndex !== null) {
                                            handleDrop(e, dropTargetIndex);
                                        }
                                    }}
                                >
                                    {humanPlayer.hand.map((card, idx) => {
                                        const isBuildingMelds = buildingPayMe || (isHumanTurn && gamePhase === 'finallaydown' && !meldBuildingComplete);
                                        const cardInSavedMeld = isBuildingMelds && cardsInMelds.has(idx);
                                        const cardInCurrentMeld = isBuildingMelds && cardsInCurrentMeld.has(idx);
                                        const cardPlayedOnWinner = cardsPlayedOnWinner.has(idx);
                                        const cardBeingDropped = cardBeingDroppedOnWinner === idx;
                                        if (cardInSavedMeld || cardInCurrentMeld || cardPlayedOnWinner || cardBeingDropped) return null;
                                        return (
                                            <React.Fragment key={idx}>
                                                {}
                                                {dropTargetIndex === idx && draggedCardIndex !== null && (
                                                    <div className="card-insertion-indicator"></div>
                                                )}
                                                <Card
                                                    card={{ ...card, isWildForRound: isWild(card, round) }}
                                                    selected={false}
                                                    inMeld={false}
                                                    draggable={true}
                                                    isDragging={draggedCardIndex === idx}
                                                    onDragStart={(e) => handleDragStart(e, idx)}
                                                    onDragOver={(e) => handleDragOver(e, idx)}
                                                    onDrop={(e) => handleDrop(e, idx)}
                                                    onDragEnd={() => handleDragEnd()}
                                                    onTouchStart={(e) => handleTouchStart(e, idx)}
                                                    onTouchMove={(e) => handleTouchMove(e, idx)}
                                                    onTouchEnd={(e) => handleTouchEnd(e, idx)}
                                                    onClick={(e) => {
                                                        if (buildingPayMe || (isHumanTurn && gamePhase === 'finallaydown' && !meldBuildingComplete)) {
                                                            toggleCardInMeld(idx);
                                                        } else if (gamePhase === 'paymediscard') {
                                                            const cardElement = e.currentTarget;
                                                            animateCardDiscard(cardElement, card, () => discardForPayMe(idx));
                                                        } else if (isHumanTurn && (gamePhase === 'discard' || gamePhase === 'finaldiscard')) {
                                                            const cardElement = e.currentTarget;
                                                            animateCardDiscard(cardElement, card, () => discardCard(idx));
                                                        }
                                                    }}
                                                    disabled={!isHumanTurn && !buildingPayMe && gamePhase !== 'paymediscard' && gamePhase !== 'finallaydown'}
                                                />
                                                {}
                                                {idx === humanPlayer.hand.length - 1 && dropTargetIndex === humanPlayer.hand.length && draggedCardIndex !== null && (
                                                    <div className="card-insertion-indicator"></div>
                                                )}
                                            </React.Fragment>
                                        );
                                    })}
                                </div>
                                {}
                                {humanFinalPlayResults && roundWinner !== null && !allFinalPlaysComplete && (
                                    <div style={{marginTop: '15px', padding: '15px', background: 'rgba(248, 249, 250, 0.95)', borderRadius: '8px'}}>
                                        <h4 style={{margin: '0 0 10px 0', color: '#856404'}}>Your Final Play</h4>
                                        <div style={{display: 'flex', gap: '15px', flexWrap: 'wrap', justifyContent: 'center'}}>
                                            {humanFinalPlayResults.melds.length > 0 && (
                                                <div>
                                                    <h5 style={{margin: '0 0 5px 0', fontSize: '12px', color: '#28a745'}}>Melds:</h5>
                                                    {humanFinalPlayResults.melds.map((meld, meldIdx) => (
                                                        <div key={meldIdx} style={{display: 'flex', gap: '3px', marginBottom: '5px'}}>
                                                            {meld.map((card, cardIdx) => (
                                                                <WinnerHandCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} showOriginalTag={false} />
                                                            ))}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            {humanFinalPlayResults.playedOnCards && humanFinalPlayResults.playedOnCards.length > 0 && (
                                                <div>
                                                    <h5 style={{margin: '0 0 5px 0', fontSize: '12px', color: '#17a2b8'}}>Played on Winner:</h5>
                                                    <div style={{display: 'flex', gap: '3px', flexWrap: 'wrap'}}>
                                                        {humanFinalPlayResults.playedOnCards.map((card, cardIdx) => (
                                                            <WinnerHandCard key={cardIdx} card={{...card, isWildForRound: isWill(card, round)}} showOriginalTag={false} />
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                            {humanFinalPlayResults.remaining.length > 0 && (
                                                <div>
                                                    <h5 style={{margin: '0 0 5px 0', fontSize: '12px', color: '#dc3545'}}>Remaining ({humanFinalPlayResults.points} pts):</h5>
                                                    <div style={{display: 'flex', gap: '3px', flexWrap: 'wrap'}}>
                                                        {humanFinalPlayResults.remaining.map((card, cardIdx) => (
                                                            <WinnerHandCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} showOriginalTag={false} />
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        {}
                        {humanPlayer.melds.length > 0 && !buildingPayMe && roundWinner === 0 && !showingHumanFinalPlay && !showingAIMelds && (
                            <div className="melds-area winner-melds">
                                <h3 style={{color: '#28a745', marginBottom: '10px'}}>ðŸ† Your Winning Hand (others can play on these):</h3>
                                {humanPlayer.melds.map((meld, idx) => (
                                    <div key={idx} className="meld-group">
                                        <div className="meld-label" style={{color: '#28a745'}}>Meld {idx + 1}:</div>
                                        <div className="cards-container">
                                            {meld.map((card, cardIdx) => (
                                                <Card key={cardIdx} card={{ ...card, isWildForRound: isWild(card, round) }} disabled={true} />
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        {}
                        {humanPlayer.melds.length > 0 && !buildingPayMe && roundWinner !== 0 && !(gamePhase === 'finaldiscard' && meldBuildingComplete) && !(gamePhase === 'finallaydown' && meldBuildingComplete) && !showingHumanFinalPlay && !showingAIMelds && !allFinalPlaysComplete && !humanFinalPlayResults && (
                            <div className="melds-area">
                                <h3>Your Melds:</h3>
                                {humanPlayer.melds.map((meld, idx) => (
                                    <div key={idx} className="meld-group">
                                        <div className="meld-label">Meld {idx + 1}:</div>
                                        <div className="cards-container">
                                            {meld.map((card, cardIdx) => (
                                                <Card key={cardIdx} card={{ ...card, isWildForRound: isWild(card, round) }} disabled={true} />
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        {}
                        {showingAIMelds && aiResultsToShow && !allFinalPlaysComplete && (
                            <button
                                className="success"
                                style={{
                                    position: 'fixed',
                                    bottom: '20px',
                                    right: '20px',
                                    zIndex: 250,
                                    fontSize: '18px',
                                    padding: '12px 30px'
                                }}
                                onClick={() => {
                                    setShowingAIMelds(false);
                                    if (nextFinalTurnActionRef.current) {
                                        nextFinalTurnActionRef.current();
                                        nextFinalTurnActionRef.current = null;
                                    }
                                }}
                            >
                                Continue
                            </button>
                        )}
                        {}
                        {allFinalPlaysComplete && roundWinner !== null && (
                            <div style={{position: 'fixed', bottom: '20px', right: '20px', zIndex: 250, display: 'flex', gap: '10px'}}>
                                <button
                                    className="success"
                                    onClick={() => openScoreboard()}
                                    style={{fontSize: '18px', padding: '12px 30px'}}
                                >
                                    Show Scoreboard
                                </button>
                                <button
                                    className="success"
                                    onClick={() => {
                                        const winnerIdx = roundWinner;
                                        setShowingHumanFinalPlay(false);
                                        setHumanFinalPlayResults(null);
                                        setShowingAIMelds(false);
                                        setAiResultsToShow(null);
                                        setAllFinalPlaysComplete(false);
                                        setPlayersWhoHaveTakenFinalTurn(new Set());
                                        setRoundWinner(null);
                                        nextFinalTurnActionRef.current = null;
                                        if (round < 11) {
                                            const updatedPlayers = players.map((player, idx) => {
                                                const roundScore = idx === winnerIdx ? 0 : calculateScore(player.hand);
                                                const newScore = player.score + roundScore;
                                                return {...player, score: newScore, hand: [], melds: [], playedOnCards: null};
                                            });
                                            setPlayers(updatedPlayers);
                                            setRound(round + 1);
                                            setDealerIndex((dealerIndex + 1) % players.length);
                                            dealCards(updatedPlayers, (dealerIndex + 1) % players.length);
                                        }
                                    }}
                                    style={{fontSize: '18px', padding: '12px 30px'}}
                                >
                                    Next Round
                                </button>
                            </div>
                        )}
                        <div className="actions">
                            {isHumanTurn && gamePhase === 'finaldiscard' && meldBuildingComplete && !showingHumanFinalPlay && (
                                <button
                                    className="success"
                                    onClick={() => {
                                        const updatedPlayers = [...players];
                                        const meldCards = [];
                                        updatedPlayers[0].melds.forEach(meld => meldCards.push(...meld));
                                        updatedPlayers[0].hand.push(...meldCards);
                                        updatedPlayers[0].melds = [];
                                        setPlayers(updatedPlayers);
                                        setMeldBuildingComplete(false);
                                        setGamePhase('finallaydown');
                                        setMessage('Build your melds. Click cards to add to Current Meld.');
                                    }}
                                >
                                    Edit My Melds
                                </button>
                            )}
                        </div>
                        {}
                        {false && humanFinalPlayResults && roundWinner !== null && !allFinalPlaysComplete && (
                            <div className="your-final-play-panel">
                                <h3>ðŸ‘¤ Your Final Play</h3>
                                <div className="final-play-content" style={{overflowX: 'auto', WebkitOverflowScrolling: 'touch'}}>
                                    <div style={{display: 'flex', gap: '8px', alignItems: 'flex-start', whiteSpace: 'nowrap'}}>
                                        {}
                                        {humanFinalPlayResults.melds.length > 0 && (
                                            <>
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#28a745', whiteSpace: 'nowrap'}}>Melds:</h5>
                                                <div style={{display: 'flex', gap: '6px'}}>
                                                    {humanFinalPlayResults.melds.map((meld, meldIdx) => (
                                                        <div key={meldIdx} style={{
                                                            display: 'flex',
                                                            gap: '3px',
                                                            padding: '4px',
                                                            border: '2px solid #28a745',
                                                            borderRadius: '4px',
                                                            background: 'rgba(40, 167, 69, 0.05)'
                                                        }}>
                                                            {meld.map((card, cardIdx) => (
                                                                <div key={`${meldIdx}-${cardIdx}`} style={{display: 'inline-block', flexShrink: 0}}>
                                                                    <WinnerHandCard
                                                                        card={{ ...card, isWildForRound: isWild(card, round) }}
                                                                        showOriginalTag={false}
                                                                    />
                                                                </div>
                                                            ))}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            {(humanFinalPlayResults.playedOnCards?.length > 0 || humanFinalPlayResults.remaining.length > 0) && (
                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                            )}
                                            </>
                                        )}
                                        {}
                                        {humanFinalPlayResults.playedOnCards && humanFinalPlayResults.playedOnCards.length > 0 && (
                                            <>
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#17a2b8', whiteSpace: 'nowrap'}}>Played on Winner:</h5>
                                                <div style={{
                                                    display: 'flex',
                                                    gap: '3px',
                                                    padding: '4px',
                                                    border: '2px solid #17a2b8',
                                                    borderRadius: '4px',
                                                    background: 'rgba(23, 162, 184, 0.05)'
                                                }}>
                                                    {humanFinalPlayResults.playedOnCards.map((card, idx) => (
                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round), addedBy: card.addedBy }} showOriginalTag={false} />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            {(humanFinalPlayResults.remaining.length > 0 || humanFinalPlayResults.discard) && (
                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                            )}
                                            </>
                                        )}
                                        {}
                                        {humanFinalPlayResults.remaining.length > 0 && (
                                            <>
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#dc3545', whiteSpace: 'nowrap'}}>
                                                    Remaining ({humanFinalPlayResults.points} pts):
                                                </h5>
                                                <div style={{
                                                    display: 'flex',
                                                    gap: '4px',
                                                    padding: '4px',
                                                    border: '2px solid #dc3545',
                                                    borderRadius: '4px',
                                                    background: 'rgba(220, 53, 69, 0.05)'
                                                }}>
                                                    {humanFinalPlayResults.remaining.map((card, idx) => (
                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            {humanFinalPlayResults.discard && (
                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                            )}
                                            </>
                                        )}
                                        {}
                                        {humanFinalPlayResults.discard && (
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#6c757d', whiteSpace: 'nowrap'}}>Discarded:</h5>
                                                <div style={{
                                                    display: 'flex',
                                                    gap: '3px',
                                                    padding: '4px',
                                                    border: '2px solid #6c757d',
                                                    borderRadius: '4px',
                                                    background: 'rgba(108, 117, 125, 0.05)'
                                                }}>
                                                    <div style={{display: 'inline-block', flexShrink: 0}}>
                                                        <WinnerHandCard card={{ ...humanFinalPlayResults.discard, isWildForRound: isWild(humanFinalPlayResults.discard, round) }} showOriginalTag={false} />
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                                    {}
                                    <div style={{paddingTop: '12px', display: 'flex', gap: '10px', justifyContent: 'flex-end', flexShrink: 0}}>
                                    {humanFinalPlayResults && (() => {
                                        const humanPlayerIndex = players.findIndex(p => p.id === humanFinalPlayResults.player.id);
                                        if (humanPlayerIndex === -1) return null;
                                        const nextIndex = (humanPlayerIndex + 1) % players.length;
                                        const isLastPlayer = nextIndex === roundWinner;
                                        if (!isLastPlayer) return null;
                                        return (
                                            <>
                                                {isLastPlayer && (
                                                    <button
                                                        className="success"
                                                        onClick={() => {
                                                            openScoreboard();
                                                        }}
                                                        style={{fontSize: '14px', padding: '8px 16px'}}
                                                    >
                                                        Show Scoreboard
                                                    </button>
                                                )}
                                                <button
                                                    className="success"
                                                onClick={() => {
                                                    if (isLastPlayer) {
                                                        const winnerIdx = roundWinner;
                                                        setShowingHumanFinalPlay(false);
                                                        setHumanFinalPlayResults(null);
                                                        setShowingAIMelds(false);
                                                        setAiResultsToShow(null);
                                                        setAllFinalPlaysComplete(false);
                                                        setPlayersWhoHaveTakenFinalTurn(new Set());
                                                        setRoundWinner(null);
                                                        nextFinalTurnActionRef.current = null;
                                                        if (round < 11) {
                                                            const updatedPlayers = players.map((player, idx) => {
                                                                const roundScore = idx === winnerIdx ? 0 : calculateScore(player.hand);
                                                                const newScore = player.score + roundScore;
                                                                const cleanMelds = player.melds.map(meld =>
                                                                    meld.map(card => ({
                                                                        rank: card.rank,
                                                                        suit: card.suit,
                                                                        isRed: card.isRed,
                                                                        id: card.id,
                                                                        representsCard: card.representsCard
                                                                    }))
                                                                );
                                                                const cleanRemainingCards = player.hand.map(card => ({
                                                                    rank: card.rank,
                                                                    suit: card.suit,
                                                                    isRed: card.isRed,
                                                                    id: card.id
                                                                }));
                                                                const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                                                                    rank: card.rank,
                                                                    suit: card.suit,
                                                                    isRed: card.isRed,
                                                                    id: card.id,
                                                                    playedOn: card.playedOn
                                                                }));
                                                                const roundData = {
                                                                    round: round,
                                                                    melds: cleanMelds,
                                                                    remainingCards: cleanRemainingCards,
                                                                    playedOnCards: cleanPlayedOnCards,
                                                                    roundScore: roundScore,
                                                                    runningScore: newScore,
                                                                    wasWinner: idx === winnerIdx
                                                                };
                                                                return {
                                                                    ...player,
                                                                    score: newScore,
                                                                    hand: [],
                                                                    melds: [],
                                                                    playedOnCards: [],
                                                                    roundHistory: [...(player.roundHistory || []), roundData]
                                                                };
                                                            });
                                                            const nextDealerIdx = (dealerIndex + 1) % updatedPlayers.length;
                                                            const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                                                            setPlayers(updatedPlayers);
                                                            setDealerIndex(nextDealerIdx);
                                                            setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                                                            startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                                                            setRound(round + 1);
                                                        }
                                                    } else {
                                                        setShowingHumanFinalPlay(false);
                                                        const nextIndex = (currentPlayerIndex + 1) % players.length;
                                                        setCurrentPlayerIndex(nextIndex);
                                                        setGamePhase('finaldraw');
                                                        setIsDiscarding(false);
                                                        const isNextHuman = !players[nextIndex].isAI;
                                                        if (isNextHuman) {
                                                            setMessage('Your final turn - draw a card');
                                                        } else {
                                                            setMessage(`${players[nextIndex].name}'s final turn...`);
                                                        }
                                                    }
                                                }}
                                                style={{fontSize: '14px', padding: '8px 16px'}}
                                            >
                                                {isLastPlayer ? 'Next Round' : 'Continue'}
                                            </button>
                                            </>
                                        );
                                    })()}
                                    </div>
                                </div>
                            )}
                        {}
                        {allFinalPlaysComplete && !showingHumanFinalPlay && (
                            <div className="score-details-modal">
                                <div className="score-details-header">
                                    <h2>Round {round} Complete - Scoreboard</h2>
                                    <button onClick={() => {
                                    }} style={{visibility: 'hidden'}}>âœ•</button>
                                </div>
                                <div className="score-details-content">
                                {}
                                {[...players]
                                    .map((player, playerIdx) => ({ player, playerIdx }))
                                    .sort((a, b) => {
                                        if (a.playerIdx === roundWinner) return -1;
                                        if (b.playerIdx === roundWinner) return 1;
                                        const aPoints = calculateScore(a.player.hand);
                                        const bPoints = calculateScore(b.player.hand);
                                        return aPoints - bPoints;
                                    })
                                    .map(({ player, playerIdx }) => {
                                    const isWinner = playerIdx === roundWinner;
                                    const points = calculateScore(player.hand);
                                    return (
                                        <div key={player.id} style={{
                                            marginBottom: '8px',
                                            padding: '8px',
                                            background: isWinner ? '#d4edda' : '#f8f9fa',
                                            border: isWinner ? '3px solid #28a745' : '2px solid #dee2e6',
                                            borderRadius: '6px'
                                        }}>
                                            {}
                                            <div style={{
                                                display: 'flex',
                                                alignItems: 'flex-start',
                                                gap: '12px',
                                                flexWrap: 'wrap'
                                            }}>
                                                {}
                                                <div style={{
                                                    display: 'flex',
                                                    flexDirection: 'column',
                                                    minWidth: '120px'
                                                }}>
                                                    <h4 style={{margin: 0, fontSize: '15px', color: isWinner ? '#28a745' : '#333'}}>
                                                        {player.avatar} {player.name} {isWinner && 'ðŸ‘‘'}
                                                    </h4>
                                                    <div style={{fontSize: '13px', fontWeight: 'bold', color: isWinner ? '#28a745' : '#dc3545', marginTop: '4px'}}>
                                                        {isWinner ? '0 pts (Winner!)' : `${points} pts`}
                                                    </div>
                                                    <div style={{fontSize: '12px', color: '#666', marginTop: '4px'}}>
                                                        Total: {player.score + points} pts
                                                    </div>
                                                </div>
                                                {}
                                                <div style={{flex: 1, overflowX: 'auto', WebkitOverflowScrolling: 'touch'}}>
                                                    <div style={{display: 'flex', gap: '8px', alignItems: 'flex-start', whiteSpace: 'nowrap'}}>
                                                        {}
                                                        {player.melds.length > 0 && (
                                                            <>
                                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                                <h5 style={{margin: 0, fontSize: '11px', color: '#28a745', whiteSpace: 'nowrap'}}>Melds:</h5>
                                                                <div style={{display: 'flex', gap: '6px'}}>
                                                                    {player.melds.map((meld, meldIdx) => (
                                                                        <div key={meldIdx} style={{
                                                                            display: 'flex',
                                                                            gap: '3px',
                                                                            padding: '4px',
                                                                            border: '2px solid #28a745',
                                                                            borderRadius: '4px',
                                                                            background: 'rgba(40, 167, 69, 0.05)'
                                                                        }}>
                                                                            {meld.map((card, cardIdx) => (
                                                                                <div key={`${meldIdx}-${cardIdx}`} style={{display: 'inline-block', flexShrink: 0}}>
                                                                                    <WinnerHandCard
                                                                                        card={{ ...card, isWildForRound: isWild(card, round) }}
                                                                                        showOriginalTag={false}
                                                                                    />
                                                                                </div>
                                                                            ))}
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                            {(player.playedOnCards?.length > 0 || player.hand.length > 0) && (
                                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                            )}
                                                            </>
                                                        )}
                                                        {}
                                                        {player.playedOnCards && player.playedOnCards.length > 0 && (
                                                            <>
                                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                                <h5 style={{margin: 0, fontSize: '11px', color: '#17a2b8', whiteSpace: 'nowrap'}}>Played on Winner:</h5>
                                                                <div style={{display: 'flex', gap: '3px'}}>
                                                                    {player.playedOnCards.map((card, idx) => (
                                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                            {player.hand.length > 0 && (
                                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                            )}
                                                            </>
                                                        )}
                                                        {}
                                                        {player.hand.length > 0 && (
                                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                                <h5 style={{margin: 0, fontSize: '11px', color: '#dc3545', whiteSpace: 'nowrap'}}>
                                                                    Remaining ({points} pts):
                                                                </h5>
                                                                <div style={{display: 'flex', gap: '4px'}}>
                                                                    {player.hand.map((card, idx) => (
                                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                                {}
                                <div style={{padding: '20px', borderTop: '2px solid #dee2e6', textAlign: 'center', background: '#f8f9fa'}}>
                                    <button
                                        className="success"
                                        onClick={() => {
                                            const winnerIdx = roundWinner;
                                            closeScoreboard();
                                            setShowingHumanFinalPlay(false);
                                            setHumanFinalPlayResults(null);
                                            setShowingAIMelds(false);
                                            setAiResultsToShow(null);
                                            if (round < 11) {
                                                const updatedPlayers = players.map((player, idx) => {
                                                    const roundScore = idx === winnerIdx ? 0 : calculateScore(player.hand);
                                                    const newScore = player.score + roundScore;
                                                    const cleanMelds = player.melds.map(meld =>
                                                        meld.map(card => ({
                                                            rank: card.rank,
                                                            suit: card.suit,
                                                            isRed: card.isRed,
                                                            id: card.id,
                                                            representsCard: card.representsCard
                                                        }))
                                                    );
                                                    const cleanRemainingCards = player.hand.map(card => ({
                                                        rank: card.rank,
                                                        suit: card.suit,
                                                        isRed: card.isRed,
                                                        id: card.id
                                                    }));
                                                    const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                                                        rank: card.rank,
                                                        suit: card.suit,
                                                        isRed: card.isRed,
                                                        id: card.id,
                                                        playedOn: card.playedOn
                                                    }));
                                                    const roundData = {
                                                        round: round,
                                                        melds: cleanMelds,
                                                        remainingCards: cleanRemainingCards,
                                                        playedOnCards: cleanPlayedOnCards,
                                                        roundScore: roundScore,
                                                        runningScore: newScore,
                                                        wasWinner: idx === winnerIdx
                                                    };
                                                    return {
                                                        ...player,
                                                        score: newScore,
                                                        hand: [],
                                                        melds: [],
                                                        playedOnCards: [],
                                                        roundHistory: [...(player.roundHistory || []), roundData]
                                                    };
                                                });
                                                const nextDealerIdx = (dealerIndex + 1) % updatedPlayers.length;
                                                const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                                                setPlayers(updatedPlayers);
                                                setDealerIndex(nextDealerIdx);
                                                setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                                                startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                                                setRound(round + 1);
                                            }
                                        }}
                                        style={{fontSize: '16px', padding: '12px 30px'}}
                                    >
                                        Continue to Next Round
                                    </button>
                                </div>
                                </div>
                            </div>
                        )}
                        {gameOver && (
                            <div className="scoreboard">
                                <h3>Final Scores</h3>
                                <table className="score-table">
                                    <thead>
                                        <tr><th>Player</th><th>Score</th><th>Quarters</th></tr>
                                    </thead>
                                    <tbody>
                                        {[...players].sort((a, b) => a.score - b.score).map(player => (
                                            <tr key={player.id}>
                                                <td>{player.avatar} {player.name}</td>
                                                <td>{player.score}</td>
                                                <td>{player.quarters}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                                <button onClick={() => window.location.reload()} style={{marginTop: '20px'}}>New Game</button>
                            </div>
                        )}
                        {}
                        {wildCardToAssign !== null && (
                            <div className="wild-picker-overlay" onClick={cancelWildAssignment}>
                                <div className="wild-picker-modal" onClick={(e) => e.stopPropagation()}>
                                    <h3>ðŸƒ Select Value for Wild Card</h3>
                                    {currentMeld[wildCardToAssign] && (
                                        <p style={{textAlign: 'center', color: '#666', marginBottom: '15px'}}>
                                            What should {currentMeld[wildCardToAssign].rank}{currentMeld[wildCardToAssign].suit} represent?
                                        </p>
                                    )}
                                    <div className="wild-picker-cards">
                                        {getPossibleWildValues().map((option, idx) => {
                                            const isRed = option.suit === 'â™¥' || option.suit === 'â™¦';
                                            return (
                                                <div
                                                    key={idx}
                                                    className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                    onClick={() => selectWildValue(option.rank, option.suit)}
                                                >
                                                    <span className="rank">{option.rank}</span>
                                                    <span className="suit">{option.suit}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    {getPossibleWildValues().length === 0 && (
                                        <p style={{textAlign: 'center', color: '#dc3545', marginBottom: '15px'}}>
                                            Add more non-wild cards to the meld first to determine possible values.
                                        </p>
                                    )}
                                    <button className="wild-picker-cancel" onClick={cancelWildAssignment}>
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        {}
                        {winnerMeldWildPicker !== null && (
                            <div className="wild-picker-overlay" onClick={cancelWinnerMeldWildPicker}>
                                <div className="wild-picker-modal" onClick={(e) => e.stopPropagation()}>
                                    <h3>ðŸƒ Where should this wild card go?</h3>
                                    <p style={{textAlign: 'center', color: '#666', marginBottom: '15px'}}>
                                        Adding {winnerMeldWildPicker.card.rank}{winnerMeldWildPicker.card.suit} to {players[roundWinner]?.name}'s meld
                                    </p>
                                    <div className="wild-picker-cards">
                                        {winnerMeldWildPicker.options.map((option, idx) => {
                                            const isRed = option.suit === 'â™¥' || option.suit === 'â™¦';
                                            return (
                                                <div
                                                    key={idx}
                                                    className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                    onClick={() => selectWinnerMeldWildValue(option.rank, option.suit)}
                                                >
                                                    <span className="rank">{option.rank}</span>
                                                    <span className="suit">{option.suit}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    <button className="wild-picker-cancel" onClick={cancelWinnerMeldWildPicker}>
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        {}
                        {showMeldPicker && (
                            <div className="wild-picker-overlay" onClick={handleMeldPickerCancel}>
                                <div className="wild-picker-modal" onClick={(e) => e.stopPropagation()} style={{maxWidth: '600px'}}>
                                    {meldPickerAllWilds ? (
                                        <>
                                            {}
                                            {meldPickerStep === 1 && (
                                                <>
                                                    <h3>Choose Meld Type</h3>
                                                    <div style={{display: 'flex', gap: '20px', justifyContent: 'center', margin: '20px 0'}}>
                                                        <button
                                                            onClick={() => handleAllWildsMeldTypeSelection('set')}
                                                            style={{padding: '15px 30px', fontSize: '18px'}}
                                                        >
                                                            Set
                                                        </button>
                                                        <button
                                                            onClick={() => handleAllWildsMeldTypeSelection('run')}
                                                            style={{padding: '15px 30px', fontSize: '18px'}}
                                                        >
                                                            Run
                                                        </button>
                                                    </div>
                                                </>
                                            )}
                                            {meldPickerStep === 2 && meldPickerSelectedType === 'set' && (
                                                <>
                                                    <h3>Choose Rank</h3>
                                                    <div className="wild-picker-cards">
                                                        {['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'].map(rank => (
                                                            <div
                                                                key={rank}
                                                                className="wild-picker-card black"
                                                                onClick={() => handleAllWildsSuitOrRankSelection(rank)}
                                                            >
                                                                <span className="rank">{rank}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </>
                                            )}
                                            {meldPickerStep === 2 && meldPickerSelectedType === 'run' && (
                                                <>
                                                    <h3>Choose Suit</h3>
                                                    <div className="wild-picker-cards">
                                                        {SUITS.map(suit => {
                                                            const isRed = suit === 'â™¥' || suit === 'â™¦';
                                                            return (
                                                                <div
                                                                    key={suit}
                                                                    className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                                    onClick={() => handleAllWildsSuitOrRankSelection(suit)}
                                                                >
                                                                    <span className="suit" style={{fontSize: '32px'}}>{suit}</span>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </>
                                            )}
                                            {meldPickerStep === 3 && meldPickerSelectedType === 'run' && (
                                                <>
                                                    <h3>Choose Starting Card</h3>
                                                    <div style={{maxHeight: '400px', overflowY: 'auto'}}>
                                                        {['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
                                                            .filter((rank, idx) => idx + currentMeld.length < 13)
                                                            .map(startRank => {
                                                                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                                                                const startIdx = rankOrder.indexOf(startRank);
                                                                if (startIdx === -1) return null;
                                                                const isRed = meldPickerSelectedSuit === 'â™¥' || meldPickerSelectedSuit === 'â™¦';
                                                                return (
                                                                    <div
                                                                        key={startRank}
                                                                        onClick={() => handleAllWildsRunSelection(startRank)}
                                                                        style={{
                                                                            display: 'flex',
                                                                            gap: '3px',
                                                                            padding: '10px',
                                                                            margin: '5px 0',
                                                                            background: '#f8f9fa',
                                                                            borderRadius: '6px',
                                                                            cursor: 'pointer',
                                                                            border: '2px solid transparent',
                                                                            transition: 'all 0.2s'
                                                                        }}
                                                                        onMouseEnter={(e) => e.currentTarget.style.borderColor = '#2a5298'}
                                                                        onMouseLeave={(e) => e.currentTarget.style.borderColor = 'transparent'}
                                                                    >
                                                                        {currentMeld.map((_, idx) => {
                                                                            const rankIdx = startIdx + idx;
                                                                            if (rankIdx >= 0 && rankIdx < rankOrder.length) {
                                                                                const rank = rankOrder[rankIdx];
                                                                                return (
                                                                                    <div
                                                                                        key={idx}
                                                                                        className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                                                        style={{pointerEvents: 'none'}}
                                                                                    >
                                                                                        <span className="rank">{rank}</span>
                                                                                        <span className="suit">{meldPickerSelectedSuit}</span>
                                                                                    </div>
                                                                                );
                                                                            }
                                                                            return null;
                                                                        })}
                                                                    </div>
                                                                );
                                                            })}
                                                    </div>
                                                </>
                                            )}
                                        </>
                                    ) : (
                                        <>
                                            {}
                                            <h3>Choose Meld Interpretation</h3>
                                            <div style={{maxHeight: '400px', overflowY: 'auto', marginBottom: '15px'}}>
                                                {}
                                                {(() => {
                                                    const cardLookupMap = new Map(currentMeld.map(c => [c.id, c]));
                                                    return meldPickerOptions.map((option, idx) => {
                                                        if (option.type === 'set' && typeof option.display === 'string') {
                                                            return (
                                                                <div
                                                                    key={idx}
                                                                    onClick={() => handleMeldPickerSelection(option)}
                                                                    style={{
                                                                        padding: '15px 20px',
                                                                        margin: '8px 0',
                                                                        background: '#f8f9fa',
                                                                        borderRadius: '6px',
                                                                        cursor: 'pointer',
                                                                        border: '2px solid transparent',
                                                                        transition: 'all 0.2s',
                                                                        textAlign: 'center',
                                                                        fontSize: '18px',
                                                                        fontWeight: '600',
                                                                        color: '#1e3c72'
                                                                    }}
                                                                    onMouseEnter={(e) => e.currentTarget.style.borderColor = '#2a5298'}
                                                                    onMouseLeave={(e) => e.currentTarget.style.borderColor = 'transparent'}
                                                                >
                                                                    {option.display}
                                                                    <div style={{
                                                                        fontSize: '12px',
                                                                        fontWeight: 'normal',
                                                                        color: '#666',
                                                                        marginTop: '5px'
                                                                    }}>
                                                                        (Suits will be auto-assigned)
                                                                    </div>
                                                                </div>
                                                            );
                                                        }
                                                        return (
                                                        <div
                                                            key={idx}
                                                            onClick={() => handleMeldPickerSelection(option)}
                                                            style={{
                                                                display: 'flex',
                                                                gap: '3px',
                                                                padding: '10px',
                                                                margin: '8px 0',
                                                                background: '#f8f9fa',
                                                                borderRadius: '6px',
                                                                cursor: 'pointer',
                                                                border: '2px solid transparent',
                                                                transition: 'all 0.2s',
                                                                justifyContent: 'center'
                                                            }}
                                                            onMouseEnter={(e) => e.currentTarget.style.borderColor = '#2a5298'}
                                                            onMouseLeave={(e) => e.currentTarget.style.borderColor = 'transparent'}
                                                        >
                                                            {option.display.map((cardStr, cardIdx) => {
                                                                const match = cardStr.match(/^(A|[2-9]|10|J|Q|K)([â™¥â™¦â™£â™ ])$/);
                                                                if (!match) return null;
                                                                const [, rank, suit] = match;
                                                                const isRed = suit === 'â™¥' || suit === 'â™¦';
                                                                const cardId = option.cardIds ? option.cardIds[cardIdx] : null;
                                                                const originalCard = cardId ? cardLookupMap.get(cardId) : currentMeld[cardIdx];
                                                                const isWildCard = originalCard && originalCard.rank && originalCard.suit && isWild(originalCard, round);
                                                                if (isWildCard) {
                                                                    const originalIsRed = originalCard.isRed !== undefined ? originalCard.isRed : (originalCard.suit === 'â™¥' || originalCard.suit === 'â™¦');
                                                                    const representedCardStr = `${rank}${suit}`;
                                                                    const representsIsRed = suit === 'â™¥' || suit === 'â™¦';
                                                                    const isJoker = originalCard.rank === 'JOKER';
                                                                    return (
                                                                        <div
                                                                            key={cardIdx}
                                                                            className={`wild-picker-card ${originalIsRed ? 'red' : 'black'}`}
                                                                            style={{
                                                                                pointerEvents: 'none',
                                                                                background: 'linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%)',
                                                                                borderColor: '#b8860b',
                                                                                position: 'relative',
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center'
                                                                            }}
                                                                        >
                                                                            {isJoker ? (
                                                                                <>
                                                                                    <div style={{
                                                                                        fontSize: '45px',
                                                                                        lineHeight: '1'
                                                                                    }}>ðŸƒ</div>
                                                                                    {}
                                                                                    <div style={{
                                                                                        position: 'absolute',
                                                                                        bottom: '3px',
                                                                                        left: '50%',
                                                                                        transform: 'translateX(-50%)',
                                                                                        fontSize: '9px',
                                                                                        fontWeight: '600',
                                                                                        background: 'rgba(255,255,255,0.9)',
                                                                                        padding: '1px 4px',
                                                                                        borderRadius: '2px',
                                                                                        border: '1px solid #b8860b',
                                                                                        color: representsIsRed ? '#e74c3c' : '#000',
                                                                                        whiteSpace: 'nowrap'
                                                                                    }}>
                                                                                        = {representedCardStr}
                                                                                    </div>
                                                                                </>
                                                                            ) : (
                                                                                <>
                                                                                    {}
                                                                                    <div style={{
                                                                                        display: 'flex',
                                                                                        flexDirection: 'column',
                                                                                        alignItems: 'center',
                                                                                        justifyContent: 'center',
                                                                                        height: '100%',
                                                                                        position: 'relative'
                                                                                    }}>
                                                                                        <div style={{
                                                                                            fontSize: '32px',
                                                                                            lineHeight: '1',
                                                                                            marginBottom: '2px'
                                                                                        }}>ðŸƒ</div>
                                                                                        <div style={{
                                                                                            fontSize: '10px',
                                                                                            fontWeight: '600',
                                                                                            color: originalIsRed ? '#e74c3c' : '#000',
                                                                                            whiteSpace: 'nowrap'
                                                                                        }}>({originalCard.rank}{originalCard.suit})</div>
                                                                                    </div>
                                                                                    {}
                                                                                    <div style={{
                                                                                        position: 'absolute',
                                                                                        bottom: '3px',
                                                                                        left: '50%',
                                                                                        transform: 'translateX(-50%)',
                                                                                        fontSize: '9px',
                                                                                        fontWeight: '600',
                                                                                        background: 'rgba(255,255,255,0.9)',
                                                                                        padding: '1px 4px',
                                                                                        borderRadius: '2px',
                                                                                        border: '1px solid #b8860b',
                                                                                        color: representsIsRed ? '#e74c3c' : '#000',
                                                                                        whiteSpace: 'nowrap'
                                                                                    }}>
                                                                                        = {representedCardStr}
                                                                                    </div>
                                                                                </>
                                                                            )}
                                                                        </div>
                                                                    );
                                                                } else {
                                                                    return (
                                                                        <div
                                                                            key={cardIdx}
                                                                            className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                                            style={{pointerEvents: 'none'}}
                                                                        >
                                                                            <span className="rank">{rank}</span>
                                                                            <span className="suit">{suit}</span>
                                                                        </div>
                                                                    );
                                                                }
                                                            })}
                                                        </div>
                                                    );
                                                });
                                            })()}
                                            </div>
                                        </>
                                    )}
                                    <button className="wild-picker-cancel" onClick={handleMeldPickerCancel}>
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        </div>
                        </div>
                    </div>
                </div>
            );
        }
        ReactDOM.render(<PayMeGame />, document.getElementById('root'));
    </script>
</body>
</html>
